I"§8<p>W tym poÅ›cie powiemy o przykÅ‚adowej Å›cieÅ¼ce optymalizacji wstawiania grup rekordÃ³w do bazy danych za pomocÄ… Hibernateâ€™a i SpringBoota z zaÅ‚oÅ¼eniem uÅ¼ycia spring-boot-starter-data-jpa.
Skupimy siÄ™ na aspektach konfiguracyjnym i diagnostycznym systemu.</p>

<p>Zapytany o to czy lepiej uÅ¼ywaÄ‡ EntityManagera czy Hibernateâ€™owego Session, Emmanuel Bernard  bez wahania opowiedziaÅ‚ siÄ™ za tym pierwszym <a href="https://www.theserverside.com/news/2240186700/The-JPA-20-EntityManager-vs-the-Hibernate-Session-Which-one-to-use">[1]</a>. Jest to wypowiedÅº zgodna z zasadÄ…, ktÃ³rÄ… jako programiÅ›ci wszyscy dobrze znamy â€“ bazowanie na specyfikacji, a nie implementacji danej technologii. Stosowanie siÄ™ do tej reguÅ‚y sprawia, Å¼e zmiany technologiczne sÄ… o wiele prostsze - jesteÅ›my zwiÄ…zani tylko z interfejsem, a podmiana dostawcy jego implementacji jest przecieÅ¼ w zaÅ‚oÅ¼eniu tylko formalnoÅ›ciÄ….</p>

<p>Zdarza siÄ™ jednak, Å¼e musimy zrobiÄ‡ coÅ› co wychodzi poza ramy abstrakcyjnej specyfikacji i chcÄ…c nie chcÄ…c uÅ¼yÄ‡ mechanizmÃ³w konkretnej implementacji. Tak jest teÅ¼ w przypadku batchowych insertÃ³w czyli zapisywania wiÄ™kszych grup rekordÃ³w w jednej transakcji. W tym poÅ›cie przejdziemy przez typowÄ… drogÄ™ optymalizacji tejÅ¼e operacji, przykÅ‚ady wizualizujÄ…c statystykami generowanymi przez Hibernateâ€™a oraz przepÅ‚ywami zilustrowanymi za pomocÄ… Zipkina <a href="https://zipkin.io/">[2]</a>.</p>

<p>ZaÅ‚Ã³Å¼my dobrze znany scenariusz - podczas spokojnego dnia w pracy nagle otrzymujemy maila:</p>

<blockquote>
  <p>ZÅ‚e wieÅ›ci!<br />
Wystawiona usÅ‚uga co prawda dziaÅ‚a, ale nie moÅ¼emy za jej pomocÄ… w jednym Å¼Ä…daniu zÅ‚oÅ¼yÄ‡ 2000 zamÃ³wieÅ„.<br />
Okazuje sie, Å¼e oczekiwanie na odpowiedÅº trwa zbyt dÅ‚ugo i dostajemy timeout!</p>
</blockquote>

<p>Nie pozostaje nam nic innego jak przystÄ…piÄ‡ do optymalizacji. Pierwsze kroki, ktÃ³ry warto podjÄ…Ä‡ to ustawienie w celach diagnostycznych wpisu konfiguracyjnego</p>
<div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">spring.jpa.properties.hibernate.generate_statistics</span><span class="p">=</span><span class="s">true</span>
</code></pre></div></div>
<p>w pliku <em>.properties</em> lub <em>.yml</em> oraz odpowiednie skonfigurowanie Zipkina (tu tÄ™ konfiguracjÄ™ pominiemy bo jest ona obszernym materiaÅ‚em, ktÃ³ry mÃ³gÅ‚by wypeÅ‚niÄ‡ osobny artykuÅ‚). Te kroki pomogÄ… nam w przeÅ›ledzeniu powodu wyjÄ…tkowo dÅ‚ugiego czasu odpowiedzi usÅ‚ugi. PrzykÅ‚ady bÄ™dziemy badaÄ‡ na realnej usÅ‚udze w dwÃ³ch wariantach â€“ Å¼Ä…danie z maÅ‚Ä… liczbÄ… encji zwizualizowane za pomocÄ… Zipkina oraz Å¼Ä…danie z duÅ¼Ä… liczbÄ… encji opisane za pomocÄ… kluczowych statystyk i czasu wykonania.
PrzejdÅºmy do analizy. Na poczÄ…tek przyjrzyjmy siÄ™ usÅ‚udze bez Å¼adnych optymalizacji.</p>

<p><img src="/assets/img/posts/2019-10-21-batchowe-inserty-w-hibernate-droga-ku-szybkosci/grafika1.png" alt="Zipkin - przepÅ‚yw na maÅ‚ej liczbie encji bez optymalizacji" /></p>

<p>Co powoduje, Å¼e widzimy tak duÅ¼o wykonanych operacji? JuÅ¼ na pierwszy rzut oka widaÄ‡, Å¼e kaÅ¼de wstawianie rekordu jest realizowane osobno. SpÃ³jrzmy na wygenerowane statystyki dla normalnego wywoÅ‚ania usÅ‚ugi (przy duÅ¼ej liczbie encji)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ÅÄ…czny czas odpowiedzi usÅ‚ugi przy wywoÅ‚aniu przez HTTP 9503ms (POSTMAN)
Kluczowe statystyki wygenerowane przez Hibernate:
195762869 nanoseconds spent preparing 4005 JDBC statements;
6984223566 nanoseconds spent executing 4005 JDBC statements;
0 nanoseconds spent executing 0 JDBC batches;
4163640487 nanoseconds spent executing 1 flushes (flushing a total of 2003 entities and 0 collections);
5927 nanoseconds spent executing 1 partial-flushes (flushing a total of 0 entities and 0 collections)
</code></pre></div></div>
<p>Ze statystyk wynika, Å¼e nie wykonaÅ‚y siÄ™ Å¼adne paczki operacji, widaÄ‡ natomiast informacjÄ™ o zrealizowaniu ponad 4000 komend JDBC. 
WÄ…skim gardÅ‚em jest sposÃ³b wstawiania rekordÃ³w do bazy danych. Jak temu zaradziÄ‡?</p>

<p>Z pomocÄ… przychodzi nam konfiguracja operacji batchowych. Skupimy siÄ™ przede wszystkim na wstawianiu rekordÃ³w. Skonfigurujmy batchowe inserty poprzez dodanie do wczeÅ›niej wspomnianych plikÃ³w konfiguracyjnych odpowiednich wpisÃ³w</p>
<div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">spring.jpa.properties.hibernate.jdbc.batch_size</span><span class="p">=</span><span class="s">1000</span>
</code></pre></div></div>

<p>DodajÄ…c ten wpis ustawiliÅ›my wielkoÅ›Ä‡ paczek w operacjach paczkowanych.
Warto rÃ³wnieÅ¼, choÄ‡ nie jest to wymagane, ustawiÄ‡ inny wpis konfiguracyjny.</p>
<div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">spring.jpa.properties.hibernate.order_inserts</span><span class="p">=</span><span class="s">true</span>
</code></pre></div></div>
<p>Jest to przydatne szczegÃ³lnie w przypadku gdy wystÄ™puje relacja encji rodzic-dziecko z kaskadowÄ… persystencjÄ…, pozwoli to w takim przypadku na zgrupowanie zapisÃ³w typami encji.</p>

<p>Po wykonaniu pierwszego kroku optymalizacyjnego sprawdÅºmy jak zmieniÅ‚y siÄ™ wygenerowane statystyki.</p>

<p><img src="/assets/img/posts/2019-10-21-batchowe-inserty-w-hibernate-droga-ku-szybkosci/grafika2.png" alt="Zipkin - przepÅ‚yw na maÅ‚ej liczbie encji po pierwszej optymalizacji" /></p>

<p>Dla duÅ¼ej liczby encji statystyki prezentujÄ… siÄ™ nastÄ™pujÄ…co:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ÅÄ…czny czas odpowiedzi usÅ‚ugi przy wywoÅ‚aniu przez HTTP 5138ms (POSTMAN)
Kluczowe statystyki wygenerowane przez Hibernate:
84610265 nanoseconds spent preparing 2006 JDBC statements;
3139685203 nanoseconds spent executing 2003 JDBC statements;
349347467 nanoseconds spent executing 4 JDBC batches;
539223064 nanoseconds spent executing 1 flushes (flushing a total of 2003 entities and 0 collections);
5446 nanoseconds spent executing 1 partial-flushes (flushing a total of 0 entities and 0 collections)
</code></pre></div></div>
<p>ZarÃ³wno z zwizualizowanego przepÅ‚ywu dla maÅ‚ej liczby encji, jak i wygenerowanych statystyk dla duÅ¼ej ich liczby widzimy, Å¼e operacji jest mniej wiÄ™cej o poÅ‚owÄ™ mniej, a wygenerowane statystyki wprost mÃ³wiÄ…, Å¼e zostaÅ‚y wykonane â€paczkiâ€ operacji. Nadal jednak wywoÅ‚aÅ„ komend JDBC jest duÅ¼o poniewaÅ¼ wciÄ…Å¼ wykonywane sÄ… indywidualne zapytania po przydziaÅ‚ numerÃ³w bazodanowej sekwencji, ktÃ³re sÅ‚uÅ¼Ä… jako identyfikatory wstawianych encji. Jak moÅ¼emy temu zaradziÄ‡?
PoczÄ…tkowa konfiguracja identyfikatora naszej encji wyglÄ…da tak:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Id</span>
<span class="nd">@GeneratedValue</span>
<span class="kd">private</span> <span class="nc">Long</span> <span class="n">transactionId</span><span class="o">;</span>
</code></pre></div></div>
<p>W praktyce oznacza to zostawienie dostawcy implementacji dowolnoÅ›ci w doborze strategii generowania id. WeÅºmy sprawy w swoje rÄ™ce i zmieÅ„my strategiÄ™ generowania id dla naszej encji na odpowiadajÄ…cÄ… naszym potrzebom.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Id</span>
<span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">SEQUENCE</span><span class="o">,</span> <span class="n">generator</span> <span class="o">=</span> <span class="s">"hilo_sequence_generator"</span><span class="o">)</span>
<span class="nd">@GenericGenerator</span><span class="o">(</span>
      <span class="n">name</span> <span class="o">=</span> <span class="s">"hilo_sequence_generator"</span><span class="o">,</span>
      <span class="n">strategy</span> <span class="o">=</span> <span class="s">"org.hibernate.id.enhanced.SequenceStyleGenerator"</span><span class="o">,</span>
      <span class="n">parameters</span> <span class="o">=</span> <span class="o">{</span>
            <span class="nd">@Parameter</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"sequence_name"</span><span class="o">,</span> <span class="n">value</span><span class="o">=</span><span class="s">"EXAMPLE_SEQ"</span><span class="o">),</span>
            <span class="nd">@Parameter</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"initial_value"</span><span class="o">,</span> <span class="n">value</span><span class="o">=</span><span class="s">"1"</span><span class="o">),</span>
            <span class="nd">@Parameter</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"increment_size"</span><span class="o">,</span> <span class="n">value</span> <span class="o">=</span> <span class="s">"100"</span><span class="o">),</span>
            <span class="nd">@Parameter</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"optimizer"</span><span class="o">,</span> <span class="n">value</span> <span class="o">=</span> <span class="s">"hilo"</span><span class="o">)</span>
      <span class="o">})</span>
<span class="kd">private</span> <span class="nc">Long</span> <span class="n">transactionId</span><span class="o">;</span>
</code></pre></div></div>
<p>Co wÅ‚aÅ›ciwie skonfigurowaliÅ›my w tym momencie?
W adnotacji GeneratedValue informujemy Hibernate by uÅ¼yÅ‚ strategii sekwencji generowania id dla encji i wskazujemy nazwÄ™ generatora. NiÅ¼ej podajemy wczeÅ›niej wspomnianÄ… nazwÄ™ generatora, klasÄ™ wskazujÄ…cÄ… na strategiÄ™ generatora, podstawowe parametry i optymalizator. Jak dziaÅ‚a ten ostatni, u nas przyjmujÄ…cy wartoÅ›Ä‡ <strong>â€hiloâ€</strong>?</p>

<p>Sam algorytm hi/lo jest opisany w wielu miejscach na internecie <a href="https://vladmihalcea.com/the-hilo-algorithm/">[3]</a>, dlatego skupimy siÄ™ tylko na tym jak dziaÅ‚a na poziomie koncepcyjnym:</p>

<p><em>Skoro nie chcemy za kaÅ¼dym razem pytaÄ‡ bazÄ™ danych o nowy numer sekwencji, to moÅ¼emy jako klient zapytaÄ‡ o niego raz na N encji (wartoÅ›Ä‡ N zostaÅ‚a przez nas ustawiona w parametrze increment_size), a pomiÄ™dzy tymi zapytaniami sami inkrementowaÄ‡ licznik.</em></p>

<p>W praktyce oznacza to, Å¼e mogÄ… powstaÄ‡ â€dziuryâ€ w numeracji, gdy w danej transakcji wstawimy jednÄ… encjÄ™ to mimo wszystko potrzebujemy numeru sekwencji z bazy danych, a w konsekwencji podbijemy jÄ… o N. Zyskiem z korzystania z tego mechanizmu jest rzadka potrzeba pytania bazy o kolejnÄ… wartoÅ›Ä‡ sekwencji.
SprawdÅºmy kolejny raz jak nasze optymalizacje wpÅ‚ynÄ™Å‚y na szybkoÅ›Ä‡ dziaÅ‚ania usÅ‚ugi.</p>

<p><img src="/assets/img/posts/2019-10-21-batchowe-inserty-w-hibernate-droga-ku-szybkosci/grafika3.png" alt="Zipkin - przepÅ‚yw na maÅ‚ej liczbie encji po drugiej optymalizacji" /></p>

<p>Dla duÅ¼ej liczby encji statystyki prezentujÄ… siÄ™ nastÄ™pujÄ…co:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ÅÄ…czny czas odpowiedzi usÅ‚ugi przy wywoÅ‚aniu przez HTTP: 1746 ms (POSTMAN)
Kluczowe statystyki wygenerowane przez Hibernate:
4294453 nanoseconds spent preparing 26 JDBC statements;
118572140 nanoseconds spent executing 23 JDBC statements;
531069793 nanoseconds spent executing 4 JDBC batches;
732899796 nanoseconds spent executing 1 flushes (flushing a total of 2003 entities and 0 collections);
5497 nanoseconds spent executing 1 partial-flushes (flushing a total of 0 entities and 0 collections)
</code></pre></div></div>
<p>Widzimy kolejny drastyczny spadek liczby wykonywanych operacji wynikajÄ…cy z tego, Å¼e nie musimy tak czÄ™sto odpytywaÄ‡ bazy o kolejne numery sekwencji.
PorÃ³wnajmy teraz Å‚Ä…czne wywoÅ‚ania usÅ‚ugi</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Stan poczÄ…tkowy â€“ bez optymalizacji: 9503 ms
Z batchowymi insertami: 5138 ms
Z batchowymi insertami i optymalizacjÄ… sekwencji: 1746 ms
</code></pre></div></div>
<p>DziÄ™ki uÅ¼yciu odpowiednich mechanizmÃ³w zmniejszyliÅ›my czas odpowiedzi naszej usÅ‚ugi o ponad 80%!
Warto wspomnieÄ‡, Å¼e przy tego typu optymalizacjach zmiany w czasach wykonywania Å¼Ä…daÅ„ mogÄ… byÄ‡ wysoce zaleÅ¼ne od uÅ¼ytych technologii, dla konkretnych baz danych istniejÄ… teÅ¼ specyficzne moÅ¼liwe optymalizacje. Dobrym przykÅ‚adem tego jest ustawienie obecne w MySQL</p>
<div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">rewriteBatchedStatements</span><span class="p">=</span><span class="s">true</span>
</code></pre></div></div>
<p>pozwalajÄ…ce na zoptymalizowanie liczby zapytaÅ„ przesyÅ‚anych w pakiecie sieciowym.</p>

<p>W przypadku optymalizacji takich jak pokazane w tym poÅ›cie warto zajrzeÄ‡ pod maskÄ™ - do dokumentacji, a nawet kodu ÅºrÃ³dÅ‚owego frameworku, a takÅ¼e zaopatrzyÄ‡ siÄ™ w dobre narzÄ™dzia wspomagajÄ…ce diagnostykÄ™ jak chociaÅ¼by wyÅ¼ej przytoczony Zipkin.</p>

<p>Warto teÅ¼ strzec siÄ™ bÅ‚Ä™dÃ³w i niepoprawnych uÅ¼yÄ‡ mechanizmÃ³w frameworkÃ³w, naleÅ¼y chociaÅ¼by pamiÄ™taÄ‡ o tym, Å¼e aby wykonaÄ‡ batch insert za pomocÄ… klasy JpaRepository z frameworku Spring musimy skorzystaÄ‡ z metody <em>saveAll</em>, a nie <em>save</em>. Osobnej optymalizacji poprzez ustawienie <em>order_updates</em> w plikach konfiguracyjnych moÅ¼e wymagaÄ‡ rÃ³wnieÅ¼ uaktualnianie rekordÃ³w. Kolejna puÅ‚apka o ktÃ³rej naleÅ¼y pamiÄ™taÄ‡ zwiÄ…zana jest z cache poziomu L1. Jak wiemy, dziaÅ‚a ono na poziomie pojedynczej transakcji. Oznacza to, Å¼e zapisujÄ…c duÅ¼Ä… liczbÄ™ encji w jednej transakcji naraÅ¼amy siÄ™ na problemy pamiÄ™ciowe.</p>

<p>PodsumowujÄ…c, wiemy Å¼e cenÄ… za wysoki poziom abstrakcji frameworkÃ³w jest to, Å¼e duÅ¼o rzeczy dzieje siÄ™ poza naszym wzrokiem. Czasem musimy wyjÅ›Ä‡ poza specyfikacjÄ™ interfejsu technologicznego i skorzystaÄ‡ z mechanizÃ³w konkretnej implementacji, takie podejÅ›cie czÄ™sto bazowane jest na eksperymentowaniu by dowiedzieÄ‡ jaki mechanizm rozwiÄ…Å¼e nasz problem. Wymaga to nieraz diagnostycznego spojrzenia na problem oraz zagÅ‚Ä™bienia siÄ™ w dokumentacjÄ™ uÅ¼ywanej przez nas technologii.</p>

:ET