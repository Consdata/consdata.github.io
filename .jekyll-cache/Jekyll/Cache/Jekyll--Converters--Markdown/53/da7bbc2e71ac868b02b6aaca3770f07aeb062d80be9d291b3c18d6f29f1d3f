I".<p>Kończąc serię dotyczącą testowania komponentów Angularowych przy pomocy Jasmine, chciałbym poruszyć temat testów kodu wykonywanego asynchronicznie.</p>

<p>Testy jednostkowe asynchronicznych aplikacji frontendowych często wydają się być zagadką dla developerów. Na szczęście twórcy narzędzi pomyśleli również o tym i dostarczyli nam narzędzia, które zdecydowanie ułatwiają pracę z testowaniem takiego kodu.</p>

<p>W tym wpisie jednak nie poruszę kwestii testowania opartego na mockowaniu/stubowaniu kodu. Jeśli jesteś zainteresowany tym tematem, zachęcam do zajrzenia do artykułu Krzysztofa Czechowskiego o <a href="/2019/11/20/testowanie-komponentow-i-serwisow.html">testowaniu serwisów</a>.</p>

<h2 id="kod-poddany-testom">Kod poddany testom</h2>

<p>W celu sprawdzenia możliwości testowania asynchronicznych wywołań weźmy na warsztat przykładowy komponent:</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">({</span>
  <span class="na">selector</span><span class="p">:</span> <span class="dl">'</span><span class="s1">app-company</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">template</span><span class="p">:</span> <span class="dl">'</span><span class="s1">&lt;div *ngIf="messageVisible" id="welcomeMessage"&gt;Hello!&lt;/div&gt;</span><span class="dl">'</span><span class="p">,</span>
<span class="p">})</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">CompanyComponent</span> <span class="p">{</span>
  <span class="nl">messageVisible</span><span class="p">:</span> <span class="nx">boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

  <span class="nx">getCompany</span><span class="p">():</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="dl">"</span><span class="s2">company</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">showMessage</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">messageVisible</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">},</span> <span class="mi">2000</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Posiada on dwie metody: jedną, która zwraca Promise z nazwą firmy oraz drugą, która wykonuje zmianę widoczności flagi po dwóch sekundach. Na podstawie tej flagi wyświetlana jest wiadomość w templacie HTML.</p>

<p>Klasa testowa, do której będą dodawane test-case’y. W tym przypadku jest ona w 100% standardowa:</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">AppComponent</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="na">fixture</span><span class="p">:</span> <span class="nx">ComponentFixture</span><span class="o">&lt;</span><span class="nx">AppComponent</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="kd">let</span> <span class="na">debugElement</span><span class="p">:</span> <span class="nx">DebugElement</span><span class="p">;</span>
  <span class="nx">beforeEach</span><span class="p">(</span><span class="k">async</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">TestBed</span><span class="p">.</span><span class="nx">configureTestingModule</span><span class="p">({</span>
      <span class="na">declarations</span><span class="p">:</span> <span class="p">[</span>
        <span class="nx">AppComponent</span>
      <span class="p">],</span>
    <span class="p">}).</span><span class="nx">compileComponents</span><span class="p">();</span>
      <span class="nx">fixture</span> <span class="o">=</span> <span class="nx">TestBed</span><span class="p">.</span><span class="nx">createComponent</span><span class="p">(</span><span class="nx">AppComponent</span><span class="p">);</span>
      <span class="nx">debugElement</span> <span class="o">=</span> <span class="nx">fixture</span><span class="p">.</span><span class="nx">debugElement</span><span class="p">;</span>
  <span class="p">}));</span>
 <span class="p">});</span>
</code></pre></div></div>

<h2 id="testowanie-metod-zwracających-promisy">Testowanie metod zwracających Promisy</h2>
<p>Jeśli chcemy przetestować metodę, która zwraca wartość opakowaną w Promise, oraz której wynik nie jest zależny od dostępności zewnętrznych usług, możemy w łatwy sposób sprawdzić zwracane przez nie wartości przy pomocy mechanizmu async/await:</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">resolves company using async/await</span><span class="dl">'</span><span class="p">,</span> <span class="k">async</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">company</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fixture</span><span class="p">.</span><span class="nx">componentInstance</span><span class="p">.</span><span class="nx">getCompany</span><span class="p">();</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">company</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="dl">"</span><span class="s2">company</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>
<p>Jeśli z jakiegoś powodu nie możesz wykorzystać async/await, to wówczas zastosowanie znajdzie tradycyjne rozwiązywanie Promisów:</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">resolves company promise manually</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">fixture</span><span class="p">.</span><span class="nx">componentInstance</span><span class="p">.</span><span class="nx">getCompany</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">company</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">expect</span><span class="p">(</span><span class="nx">company</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="dl">"</span><span class="s2">company</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div>

<h2 id="oczekiwanie-na-wykonanie-metody-przy-użyciu-fakeasync">Oczekiwanie na wykonanie metody przy użyciu fakeAsync</h2>
<p>Metoda <code class="language-plaintext highlighter-rouge">showMessage()</code> z naszego komponentu ma narzucony czas dwóch sekund oczekiwania przed jej wykonaniem.
W teście możemy powtórzyć ten zabieg i po wywołaniu metody uruchomić asercje wewnątrz <code class="language-plaintext highlighter-rouge">setTimeout()</code>. Jednak wprowadzanie realnego czasu oczekiwania nie jest efektywnym rozwiązaniem i bardzo spowolni nasze testy. Dzięki Angularowemu <code class="language-plaintext highlighter-rouge">fakeAsync</code> możemy testować kod asynchroniczny, w synchroniczny sposób.</p>

<p>Zobaczmy:</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">it</span><span class="p">(</span><span class="dl">"</span><span class="s2">tests the message visibility</span><span class="dl">"</span><span class="p">,</span> <span class="nx">fakeAsync</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">fixture</span><span class="p">.</span><span class="nx">componentInstance</span><span class="p">.</span><span class="nx">showMessage</span><span class="p">();</span>
  <span class="nx">tick</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
  <span class="nx">fixture</span><span class="p">.</span><span class="nx">detectChanges</span><span class="p">();</span>
  <span class="nx">fixture</span><span class="p">.</span><span class="nx">whenStable</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">helloMessage</span> <span class="o">=</span> <span class="nx">fixture</span><span class="p">.</span><span class="nx">debugElement</span><span class="p">.</span><span class="nx">query</span><span class="p">(</span><span class="nx">By</span><span class="p">.</span><span class="nx">css</span><span class="p">(</span><span class="dl">"</span><span class="s2">#welcomeMessage</span><span class="dl">"</span><span class="p">));</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">helloMessage</span><span class="p">).</span><span class="nx">toBeTruthy</span><span class="p">();</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">helloMessage</span><span class="p">.</span><span class="nx">nativeElement</span><span class="p">.</span><span class="nx">innerHTML</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello!</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">})</span>
<span class="p">}));</span>
</code></pre></div></div>
<p>Spoglądając od góry:</p>
<ul>
  <li>najpierw opakowujemy nasz test jednostkowy w blok fakeAsync(), który pozwala nam oszukać asynchroniczny przepływ,</li>
  <li>wywołujemy asynchroniczną metodę,</li>
  <li>symulujemy upływ czasu - w rzeczywistości nie trwa to dwóch sekund, jednak aplikacja “myśli”, że tyle upłynęło,</li>
  <li>wykrywamy zmiany, a kiedy detekcja zmian się zakończy, robimy tradycyjne asercje.</li>
</ul>

<p>A co jeśli nie znamy czasu, który powinien upłynąć zanim wykonamy asercje? W miejscu <code class="language-plaintext highlighter-rouge">tick(2000)</code>, możemy wykorzystać <code class="language-plaintext highlighter-rouge">flush()</code> i efekt będzie dokładnie taki sam. Czym się charakteryzuje <code class="language-plaintext highlighter-rouge">flush()</code>? Podobnie jak tick, symuluje on upływ czasu, jednak robi do momentu opustoszenia kolejki macrotasków (czyli m.in. setTimeout, setInterval).</p>

<h2 id="testowanie-kodu-asynchronicznego---podsumowanie">Testowanie kodu asynchronicznego - podsumowanie</h2>

<p>Dzięki uzbrojeniu JavaScriptu w wygodne mechanizmy oraz ułatwieniom ze strony Angulara, testowanie jednostkowe kodu działającego asynchronicznie staje się nawet nie tyle proste, co całkiem przyjemne.</p>
:ET