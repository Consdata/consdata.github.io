I"_n<h2 id="awaria">Awaria:</h2>
<p>Do katastrofy prowadzi często splot różnych czynników, które w pojedynkę nie stanowią większego zagrożenia. Wymieńmy więc:</p>
<ul>
  <li>system, z którym się komunikujemy miewa od czasu do czasu długi czas odpowiedzi - no, cóż zdarza się, cztery dziewiątki to wciąż 0,01% możliwych faili, przy 0.5 miliona requestów dziennie, wychodzi jakieś 5000 - rozwiązanie: dłuższe timeouty;</li>
  <li>zdarzają się dłuższe przerwy, np. system nie działa parę minut - brak bezprzerwowych wdrożeń, problemy ze stabilnością środowiska - póki nie wpływa to bezpośrednio na user experience jest do ogrania, np. za pomocą kolejek;</li>
  <li>ograniczona liczba wątków w kontenerze aplikacji - sprzęt kosztuje czy to w chmurze czy we własnej serwerowni.</li>
</ul>

<p>Całkiem prawdopodobny scenariusz awarii: System zewnętrzny przestaje odpowiadać. Z racji tego, że timeouty mamy dosyć wysokie do obsługi rosnącej liczby requestów w naszej aplikacji przydzielane są kolejne wątki kontenera. Dochodzimy do momentu, w którym wszystkie wątki są w użyciu (np. w Tomcacie domyślnie jest 100). Jeżeli w tym samym kontenerze działają inne usługi to obsługa requesta w każdej z nich czeka na wolny wątek. Co za tym idzie wywołania usług, które do tej pory odpowiadały bardzo szybko i nie potrzebują do swojego działania systemu zewnętrznego są de facto od niego zależne. Awaria występuje dosyć szybko do wykorzystania 100 wątków wystarczy ruch 50 requestów/s i timeout 2000 ms.</p>

<p>Poniżej filmik z przykładowego scenariusza takiej awarii. W lewym oknie widzimy czasy odpowiedzi aplikacji niezależnej od systemu zewnętrznego, w prawej aplikacja korzystające z tego systemu z timeoutem 800 ms. W celach przykładu liczba wątków serwera webowego została ograniczona do pięciu. W 25 sekundzie zewnętrzny system zostaje wyłączony. Aplikacja korzystająca z niego, co zrozumiałe zwiększa czasy odpowiedzi do 800 ms. Niestety z powodu zajętości wątków serwera aplikacja niezależąca od zewnętrznego systemu (lewe okno) zwiększa czasy odpowiedzi z 12 ms do prawie 50 ms. Czyli czas odpowiedzi wydłuża się 4 krotnie.</p>

<iframe class="youtube" src="https://www.youtube.com/embed/2_jwbTviNoI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>Czy można jakoś takiej sytuacji zaradzić? Co chcielibyśmy osiągnąć?</p>

<h2 id="próba-ograniczenia-skutków">Próba ograniczenia skutków:</h2>
<p>Po pierwsze: Spróbujmy ograniczyć propagację awarii na pozostałe komponenty systemu. Skoro system zewnętrzny nie odpowiada w przewidzianym przez nas czasie nie ma sensu bombardowania go kolejnymi requestami. Może jeżeli damy mu trochę czasu dojdzie do ładu. Załóżmy, że system nie działa i nie czekajmy 800 ms na odpowiedź. Co jakiś czas sprawdźmy czy czasem nie wstał.</p>

<p>Taki model działania realizuje <a href="http://martinfowler.com/bliki/CircuitBreaker.html">circuit breaker opisany przez Martina Fowlera</a>. Implementację możemy znaleźć np. w <a href="https://github.com/Netflix/Hystrix">hystrixie</a>, bibliotece wchodzącej w skład stacka Netflix’a.</p>

<p>W testowanym przykładzie posługujemy się prostą spring boot’ową aplikacją składającą się z kontrolera:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">pl.consdata.hystrix.example.hystrixservice</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RequestMapping</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RestController</span><span class="o">;</span>

<span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RandomGeneratorController</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">RandomGeneratorServiceClient</span> <span class="n">randomGeneratorServiceClient</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">RandomGeneratorController</span><span class="o">(</span><span class="nc">RandomGeneratorServiceClient</span> <span class="n">randomGeneratorServiceClient</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">randomGeneratorServiceClient</span> <span class="o">=</span> <span class="n">randomGeneratorServiceClient</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/random"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="nf">getRandom</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">randomGeneratorServiceClient</span><span class="o">.</span><span class="na">getRandom</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>klienta serwisu zewnętrznego:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">pl.consdata.hystrix.example.hystrixservice</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.cloud.netflix.feign.FeignClient</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RequestMapping</span><span class="o">;</span>

<span class="nd">@FeignClient</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"random-generator-service"</span><span class="o">,</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"http://localhost:8080"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">RandomGeneratorServiceClient</span> <span class="o">{</span>

    <span class="nd">@RequestMapping</span>
    <span class="nc">String</span> <span class="nf">getRandom</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Sama klasa aplikacji spring boot wygląda tak:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">pl.consdata.hystrix.example.hystrixservice</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.boot.SpringApplication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.boot.autoconfigure.SpringBootApplication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.cloud.netflix.feign.EnableFeignClients</span><span class="o">;</span>

<span class="nd">@EnableFeignClients</span>
<span class="nd">@SpringBootApplication</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HystrixApplication</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">HystrixApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Używamy klienta <a href="https://github.com/OpenFeign/feign">Feign</a> pochodzącego również z biblioteki Netflixa. Feign zawiera w sobie wiele predefiniowanych konfiguracji co znacznie upraszcza powstający kod, aczkolwiek czasami utrudnia nieco zrozumienie co się dzieje w programie ;-) - szczegóły poniżej.</p>

<p>W przykładowej aplikacji potrzebny jest jeszcze plik application.properties zawierający następujące ustawienia:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server.port<span class="o">=</span>8090                <span class="c">#zmiana portu serwera webowego</span>
feign.hystrix.enabled<span class="o">=</span><span class="nb">false</span>     <span class="c">#wyłączenie domyślnej konfiguracji hystrixa</span>
server.tomcat.max-threads<span class="o">=</span>5     <span class="c">#ograniczenie liczby wątków serwera dla celów naukowych (NIE UŻYWAJ NA PRODUKCJI!!!)</span>
</code></pre></div></div>

<h2 id="dodajemy-circuit-breakera">Dodajemy circuit breaker’a:</h2>
<p>Aby dodać circuit breakera do naszej aplikacji należy:</p>

<ul>
  <li>Dodać klasę opakowującą klienta serwisu zewnętrznego komendą hystrixową (adnotacje dostarczane są przez bibliotekę <a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica">javanica</a>):
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kn">package</span> <span class="nn">pl.consdata.hystrix.example.hystrixservice</span><span class="o">;</span>

  <span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>
  <span class="kn">import</span> <span class="nn">org.springframework.stereotype.Service</span><span class="o">;</span>

  <span class="kn">import</span> <span class="nn">com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand</span><span class="o">;</span>

  <span class="nd">@Service</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">RandomGeneratorServiceClientHystrixAware</span> <span class="o">{</span>

      <span class="kd">final</span> <span class="kd">private</span> <span class="nc">RandomGeneratorServiceClient</span> <span class="n">randomGeneratorServiceClient</span><span class="o">;</span>

      <span class="nd">@Autowired</span>
      <span class="kd">public</span> <span class="nf">RandomGeneratorServiceClientHystrixAware</span><span class="o">(</span><span class="nc">RandomGeneratorServiceClient</span> <span class="n">randomGeneratorServiceClient</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">randomGeneratorServiceClient</span> <span class="o">=</span> <span class="n">randomGeneratorServiceClient</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="nd">@HystrixCommand</span><span class="o">(</span><span class="n">commandKey</span> <span class="o">=</span> <span class="s">"randomCommand"</span><span class="o">)</span>
      <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getRandom</span><span class="o">()</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">randomGeneratorServiceClient</span><span class="o">.</span><span class="na">getRandom</span><span class="o">();</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>W kontrolerze zastąpić wywołania RandomGeneratorServiceClient’a wywołaniami RandomGeneratorServiceClientHystrixAware:
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kn">package</span> <span class="nn">pl.consdata.hystrix.example.hystrixservice</span><span class="o">;</span>

  <span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RequestMapping</span><span class="o">;</span>
  <span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RestController</span><span class="o">;</span>

  <span class="nd">@RestController</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">RandomGeneratorController</span> <span class="o">{</span>

      <span class="kd">private</span> <span class="kd">final</span> <span class="nc">RandomGeneratorServiceClientHystrixAware</span> <span class="n">randomGeneratorServiceClient</span><span class="o">;</span>

      <span class="kd">public</span> <span class="nf">RandomGeneratorController</span><span class="o">(</span><span class="nc">RandomGeneratorServiceClientHystrixAware</span> <span class="n">randomGeneratorServiceClient</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">randomGeneratorServiceClient</span> <span class="o">=</span> <span class="n">randomGeneratorServiceClient</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/random"</span><span class="o">)</span>
      <span class="nc">String</span> <span class="nf">getRandom</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">randomGeneratorServiceClient</span><span class="o">.</span><span class="na">getRandom</span><span class="o">();</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>Dodać adnotację @EnableCircuitBreaker do konfiguracji aplikacji:
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kn">package</span> <span class="nn">pl.consdata.hystrix.example.hystrixservice</span><span class="o">;</span>

  <span class="kn">import</span> <span class="nn">org.springframework.boot.SpringApplication</span><span class="o">;</span>
  <span class="kn">import</span> <span class="nn">org.springframework.boot.autoconfigure.SpringBootApplication</span><span class="o">;</span>
  <span class="kn">import</span> <span class="nn">org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker</span><span class="o">;</span>
  <span class="kn">import</span> <span class="nn">org.springframework.cloud.netflix.feign.EnableFeignClients</span><span class="o">;</span>

  <span class="nd">@EnableCircuitBreaker</span>
  <span class="nd">@EnableFeignClients</span>
  <span class="nd">@SpringBootApplication</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">HystrixApplication</span> <span class="o">{</span>

      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
          <span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">HystrixApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>Dodać konfigurację hystrixa w pliku application.properties:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  server.port<span class="o">=</span>8090
  feign.hystrix.enabled<span class="o">=</span><span class="nb">false
  </span>server.tomcat.max-threads<span class="o">=</span>5

  hystrix.command.randomCommand.execution.isolation.thread.timeoutInMilliseconds<span class="o">=</span>800  <span class="c">#timeout komendy hystrixowej "randomCommand" zdefinowanej w klasie RandomGeneratorServiceClientHystrixAware adnotacją @HystrixCommand(commandKey = "randomCommand")</span>
  hystrix.command.randomCommand.circuitBreaker.requestVolumeThreshold<span class="o">=</span>10              <span class="c">#liczba requestów, dla których musi wystąpić timeout w 10 sekundowym oknie, aby circuit breaker otworzył obwód</span>
  hystrix.command.randomCommand.metrics.rollingStats.timeInMilliseconds<span class="o">=</span>10000         <span class="c">#czas okna, w którym zliczane są błędne requesty</span>
</code></pre></div>    </div>
  </li>
  <li>Dodać zależność na biblioteki hystrixowe:
    <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">"http://maven.apache.org/POM/4.0.0"</span>
  <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
  <span class="na">xsi:schemaLocation=</span><span class="s">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>

      <span class="nt">&lt;groupId&gt;</span>pl.consdata.hystrix.example<span class="nt">&lt;/groupId&gt;</span>
      <span class="nt">&lt;artifactId&gt;</span>hystrixservice<span class="nt">&lt;/artifactId&gt;</span>
      <span class="nt">&lt;version&gt;</span>1.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>

      <span class="nt">&lt;dependencies&gt;</span>
          <span class="nt">&lt;dependency&gt;</span>
              <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
              <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-web<span class="nt">&lt;/artifactId&gt;</span>
          <span class="nt">&lt;/dependency&gt;</span>
          <span class="nt">&lt;dependency&gt;</span>
              <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
              <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-feign<span class="nt">&lt;/artifactId&gt;</span>
              <span class="nt">&lt;version&gt;</span>1.2.2.RELEASE<span class="nt">&lt;/version&gt;</span>
          <span class="nt">&lt;/dependency&gt;</span>
          <span class="nt">&lt;dependency&gt;</span>
              <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
              <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-hystrix<span class="nt">&lt;/artifactId&gt;</span>
              <span class="nt">&lt;version&gt;</span>1.2.3.RELEASE<span class="nt">&lt;/version&gt;</span>
          <span class="nt">&lt;/dependency&gt;</span>
      <span class="nt">&lt;/dependencies&gt;</span>

      <span class="nt">&lt;dependencyManagement&gt;</span>
          <span class="nt">&lt;dependencies&gt;</span>
              <span class="nt">&lt;dependency&gt;</span>
                  <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
                  <span class="nt">&lt;artifactId&gt;</span>spring-boot-dependencies<span class="nt">&lt;/artifactId&gt;</span>
                  <span class="nt">&lt;version&gt;</span>1.4.2.RELEASE<span class="nt">&lt;/version&gt;</span>
                  <span class="nt">&lt;type&gt;</span>pom<span class="nt">&lt;/type&gt;</span>
                  <span class="nt">&lt;scope&gt;</span>import<span class="nt">&lt;/scope&gt;</span>
              <span class="nt">&lt;/dependency&gt;</span>
          <span class="nt">&lt;/dependencies&gt;</span>
      <span class="nt">&lt;/dependencyManagement&gt;</span>
  <span class="nt">&lt;/project&gt;</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Poniższy film pokazuje jak zachowuje się zmodyfikowana aplikacja. W lewym oknie czas odpowiedzi aplikacji niekorzystającej z systemu zewnętrznego. W prawej tak jak poprzednio czasy aplikacji korzystającej z tego systemu.</p>

<iframe class="youtube" src="https://www.youtube.com/embed/i535Xhhwabc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>W 20 sekundzie filmu wyłączony zostaje system zewnętrzny. Skutkuje to wzrostem czasów odpowiedzi aplikacji z niego korzystającej do 800 ms. Czasy odpowiedzi aplikacji niezależnej również wzrastają - do tej pory jeszcze nic się nie zmieniło względem pierwotnego zachowania. Po około 10 sekundach circuit breaker otwiera obwód i klient od razu odpowiada, że system jest niedostępny - czasy wywołania spadają, czasy wywołania niezależnej aplikacji wracają do normy. Co jakiś czas widać w prawym oknie nieco dłuższe czasy wywołania - to hystrix sprawdza czy system zewnętrzny jest już dostępny. Około 50 sekundy system zewnętrzny zostaje ponownie włączony.</p>

<h2 id="próba-zachowania-funkcjonalności">Próba zachowania funkcjonalności:</h2>
<p>Hystrix umożliwia nam podjęcie akcji naprawczej w momencie wystąpienia błędu. Aby skonfigurować taką akcję należy uzupełnić pole fallbackMethod w adnotacji HystrixCommand:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">pl.consdata.hystrix.example.hystrixservice</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Service</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand</span><span class="o">;</span>

<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RandomGeneratorServiceClientHystrixAware</span> <span class="o">{</span>

    <span class="kd">final</span> <span class="kd">private</span> <span class="nc">RandomGeneratorServiceClient</span> <span class="n">randomGeneratorServiceClient</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="nf">RandomGeneratorServiceClientHystrixAware</span><span class="o">(</span><span class="nc">RandomGeneratorServiceClient</span> <span class="n">randomGeneratorServiceClient</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">randomGeneratorServiceClient</span> <span class="o">=</span> <span class="n">randomGeneratorServiceClient</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@HystrixCommand</span><span class="o">(</span><span class="n">commandKey</span> <span class="o">=</span> <span class="s">"randomCommand"</span><span class="o">,</span> <span class="n">fallbackMethod</span> <span class="o">=</span> <span class="s">"getRandomFallback"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getRandom</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">randomGeneratorServiceClient</span><span class="o">.</span><span class="na">getRandom</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">getRandomFallback</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="k">new</span> <span class="nc">Random</span><span class="o">().</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>W tym przykładzie jako fallbackMethod podaliśmy metodę prywatną getRandomFallback, która bierze na siebie odpowiedzialność generowania liczby losowej. Taka implementacja powoduje, że każdy request do naszej aplikacji zwróci poprawną odpowiedź. Nawet kiedy system zewnętrzny będzie niedostępny. Od chwili wystąpienia awarii do momentu otworzenia obwodu przez circuit breakera czasy odpowiedzi będą zbliżone do timeoutu skonfigurowanego dla systemu zewnętrznego. Po otworzeniu obwodu metoda fallbackowa będzie wywoływana od razu - co oznacza, że czasy wywołania powrócą do standardowych lub niższych wartości.</p>

<h2 id="ciekawostki">Ciekawostki:</h2>
<h3 id="konfiguracja-klienta-feign">Konfiguracja klienta Feign:</h3>
<p>FeignClient dostarcza wielu standardowych konfiguracji. W zasadzie wystarczy gdy w adnotacji wypełnimy pole url. Jeżeli chcemy jednak zmienić jakiś parametr konfiguracji możemy uzupełnić pole configuration podając nazwę klasy zawierająca springową konfigurację beanów. Jeżeli chcemy np. zmodyfikować standardową konfigurację timeoutów dodajemy beana:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Bean</span>
<span class="nc">Request</span><span class="o">.</span><span class="na">Options</span> <span class="nf">options</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">Request</span><span class="o">.</span><span class="na">Options</span><span class="o">(</span><span class="mi">750</span><span class="o">,</span> <span class="mi">200</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Pierwszy parametr konstruktora to connection timeout, drugi read timeout. Dostarczając taką konfigurację spodziewalibyśmy się, że po 750 ms dostaniemy timeout połączenia i tu niespodzianka, …dostaniemy go po 3750 ms. A to dlatego, że FeignClient zawiera w sobie retryer’a, który domyślnie 5 razy powtarza wywołanie. Aby to zmienić należy dostarczyć w klasie konfiguracji beana:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Bean</span>
<span class="nc">Retryer</span><span class="o">.</span><span class="na">Default</span> <span class="nf">retryer</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">Retryer</span><span class="o">.</span><span class="na">Default</span><span class="o">(</span><span class="mi">10000L</span><span class="o">,</span> <span class="mi">3000</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Ostatni parametr to liczba powtórzeń.</p>

<h3 id="leniwa-inicjalizacja-komend-hystrixa">Leniwa inicjalizacja komend hystrixa:</h3>
<p>Zainstancjonowanie komendy hystrixowej odbywa się podczas pierwszego jej użycia. Może nieść to ze sobą pewne przykre konsekwencje, gdyż inicjalizacja takiej komendy co ciekawe potrafi trwać dość długo. Hystrix próbuje na różne sposoby ustalić wszystkie parametry komendy (jest ich dużo). W produkcyjnej konfiguracji zdarzało się czas ten wynosił nawet 1000 - 2000 ms. Oznacza to, że po restarcie serwera czas pierwszego wywołania komendy może się znacznie różnić od kolejnych i może to doprowadzić do przekroczenia jakiegoś ustalonego czasu odpowiedzi. Implementując w ten sposób usługi synchroniczne warto moim zdaniem rozważyć wprowadzenie specjalnego ‘pustego’ wywołania, które spowoduje zainicjalizowanie krytycznych komend. Takie rozwiązanie wydaje się być nieco infantylne, ale rzeczywiście nie ma na to rady.</p>
:ET