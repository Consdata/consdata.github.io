I"µ.<p>KaÅ¼da aplikacja rozwijana odpowiednio dÅ‚ugi czas moÅ¼e rozrosnÄ…Ä‡ siÄ™Â do ogromnych rozmiarÃ³w, a konkretniej do sporej liczby komponentÃ³w, jeÅ¼eli mÃ³wimy o aplikacji frontendowej pisanej z wykorzystaniem Angulara. Z czasem przyrost kolejnych funkcjonalnoÅ›ci moÅ¼e spowodowaÄ‡, Å¼e nasz produkt przestanie speÅ‚niaÄ‡ oczekiwania odnoÅ›nie wydajnoÅ›ci. W takim momencie powinniÅ›my pomyÅ›leÄ‡ nad moÅ¼liwoÅ›ciami naprawy tego problemu. W tym artykule pokaÅ¼emy jedno z moÅ¼liwych rozwiÄ…zaÅ„ tego problemu - zmiana strategii detekcji zmian.</p>

<h2 id="detekcja-zmian">Detekcja zmian</h2>

<p>ZaÅ‚Ã³Å¼my, Å¼e mamy przed sobÄ… kod aplikacji odpowiedzialnej za zarzÄ…dzanie hodowlÄ… zwierzÄ…t. PrzykÅ‚adowym komponentem odpowiedzialnym za wyÅ›wietlanie informacji o krÃ³wkach byÅ‚by cow-run.component, czyli wybieg krÃ³wek, ktÃ³ry przekazuje obiekt pojedynczej krÃ³wki do cow.component. Z drugiej strony mamy pig-run.component, ktÃ³ry speÅ‚nia te same zaÅ‚oÅ¼enia co komponent krÃ³wek. PrzykÅ‚adowe drzewo komponentÃ³w mogÅ‚oby wyglÄ…daÄ‡ tak:</p>

<p><img alt="Zobrazowanie drzewa komponentÃ³w" src="/assets/img/posts/2019-05-29-angular-onpush-strategy/components.png" /></p>

<p>Angular dla kaÅ¼dego komponentu tworzy odpowiadajÄ…cy jemu (komponentowi) ChangeDetector. PrzejdÅºmy dalej, czyli jak to dziaÅ‚a?</p>

<h3 id="jak-to-dziaÅ‚a">Jak to dziaÅ‚a?</h3>
<p>DomyÅ›lnie ChangeDetector nasÅ‚uchuje na kaÅ¼dÄ… zmianÄ™ stanu aplikacji - zmianÄ™ inputÃ³w, zmianÄ™ modelu prezentowanego na templatce, wywoÅ‚ania asynchroniczne, zdarzenia DOM, interwaÅ‚y. KaÅ¼da taka zmiana powoduje porÃ³wnanie obecnie prezentowanych w drzewie DOM wartoÅ›ci do tych, ktÃ³re przechowuje komponent - w momencie wykrycia rÃ³Å¼nic komponent oznaczany jest jako â€œbrudnyâ€ - proces ten nazywa siÄ™ â€œdirty checkingâ€. NastÄ™pnie dokonywana jest projekcja modelu na drzewo DOM, czyli faktyczne zaktualizowanie widoku.</p>

<p>Detekcja zmian w kaÅ¼dym Å›wieÅ¼o utworzonym komponencie ustawiona jest na wartoÅ›Ä‡ ChangeDetectionStrategy.Default, co przekÅ‚ada siÄ™ na detekcjÄ™ zmian strategiÄ… CheckAlways. Strategia ta sprawia, Å¼e podczas kaÅ¼dej zmiany stanu aplikacji - asynchronicznego zapytania wysyÅ‚anego do serwera, zdarzenia DOM, interakcji uÅ¼ytkownika z naszÄ… aplikacjÄ… sprawdzane jest caÅ‚e drzewo komponentÃ³w. WyobraÅºmy sobie sytuacjÄ™, kiedy zdarzenie DOM zostaÅ‚o wyemitowane przez CowComponent. Angular zanim sprawdziÅ‚by komponent, ktÃ³ry faktycznie wyemitowaÅ‚ zdarzenie, musiaÅ‚by sprawdziÄ‡ wszystkie komponenty, zgodnie z utworzonym przez siebie drzewem. SpÃ³jrzmy na obrazek:</p>

<p><img alt="Sprawdzanie komponentÃ³w przez mechanizm detekcji zmian" src="/assets/img/posts/2019-05-29-angular-onpush-strategy/change-detection.png" /></p>

<p>StrzaÅ‚ki obrazujÄ… kierunek przechodzenia przez drzewo mechanizmu detekcji. Jest to prosty przykÅ‚ad, gdyÅ¼ drzewo jest bardzo maÅ‚e. WyobraÅºmy sobie jednak drzewo zbudowane z setek komponentÃ³w. Z kaÅ¼dÄ… zmianÄ… Angular musiaÅ‚by na nowo przeszukaÄ‡ caÅ‚e drzewo komponentÃ³w celem znalezienia tego komponentu, ktÃ³ry wyemitowaÅ‚ zmianÄ™. DoÅ›Ä‡ sporo obliczeÅ„, czyÅ¼ nie?</p>

<h2 id="strategia-onpush">Strategia onPush</h2>
<p>Na szczÄ™Å›cie Angular pozwala nam na zmianÄ™ domyÅ›lnej strategii detekcji zmian. JeÅ¼eli nie chcemy korzystaÄ‡ z domyÅ›lnego mechanizmu, to na ratunek przychodzi nam strategia onPush! Strategia ta mÃ³wi nam, Å¼e komponent zaleÅ¼ny jest tylko i wyÅ‚Ä…cznie od swoich inputÃ³w. Taki komponent nazywamy â€œczystymâ€. Zmiana propagowana jest w momencie zmiany referencji inputÃ³w komponentu jak i w przypadku wyemitowania zdarzenia DOM w szablonie komponentu (np. klikniÄ™cie w przycisk - event onclick). Co wiÄ™cej, komponent emitujÄ…cy zmianÄ™ z wykorzystaniem strategii onPush powiadamia mechanizm detekcji Angulara, Å¼e to wÅ‚aÅ›nie on wyemitowaÅ‚ zmianÄ™! To drastycznie zmniejsza koszt przeszukania drzewa komponentÃ³w, gdyÅ¼ Angular wie, ktÃ³rego komponentu szukaÄ‡, albo ktÃ³ry komponent pominÄ…Ä‡. ZdjÄ™cie poniÅ¼ej pozwoli zobrazowaÄ‡ tÄ™ sytuacjÄ™.
<img alt="Sprawdzanie komponentÃ³w przez mechanizm detekcji zmian" src="/assets/img/posts/2019-05-29-angular-onpush-strategy/onpush-detection.png" /></p>

<h3 id="jak-uÅ¼ywaÄ‡">Jak uÅ¼ywaÄ‡?</h3>
<p>UÅ¼ywanie takiej strategii wymusza na nas zmiany podejÅ›cia odnoÅ›nie projektowania naszych komponentÃ³w. Inputy czystego komponentu powinny byÄ‡ niezmienialne, co oznacza,Â Å¼e wartoÅ›ci naszych inputÃ³w powinny byÄ‡ aktualizowane przez zmianÄ™ referencji, a nie wartoÅ›ci. Prosty przykÅ‚ad:</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Input</span><span class="p">()</span> <span class="nx">cowDonation</span><span class="p">:</span> <span class="p">{</span> <span class="nl">donation</span><span class="p">:</span> <span class="kr">number</span> <span class="p">};</span>

<span class="nx">onClickUpdateDonation</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">cowDonation</span><span class="p">.</span><span class="nx">donation</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>
<p>PowyÅ¼sza zmiana nie zadziaÅ‚a, poniewaÅ¼ zmieniamy wartoÅ›Ä‡, a nie referencjÄ™. Aby strategia onPush zadziaÅ‚aÅ‚a, wartoÅ›Ä‡ dotacji musimy zmieniÄ‡ poprzez zmianÄ™ referencji, czyli przykÅ‚adowo:</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Input</span><span class="p">()</span> <span class="nx">cowDonation</span><span class="p">:</span> <span class="p">{</span> <span class="nl">donation</span><span class="p">:</span> <span class="kr">number</span> <span class="p">};</span>

<span class="nx">updateDonation</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">cowDonation</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">donation</span><span class="p">:</span> <span class="mi">500</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Zdarzenia DOM sÄ… zdarzeniami asynchronicznymi, wiÄ™c moglibyÅ›my wyciÄ…gnÄ…Ä‡ wniosek: detekcja zmian zadziaÅ‚a, kiedy uÅ¼yjemy takich funkcji asynchronicznych jak setTimeout, setInterval albo subskrypcja do Observableâ€™a zwracanego przez serwis HTTP, prawda? OtÃ³Å¼ nie. Na szczÄ™Å›cie w przypadku bytÃ³w typu Observable Angular przychodzi nam z pomocÄ… i udostÄ™pnia AsyncPipe. Dlaczego to dziaÅ‚a z uÅ¼yciem AsyncPipe a nie z manualnÄ… subskrypcjÄ…? Zajrzyjmy wiÄ™c w kod:</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">_updateLatestValue</span><span class="p">(</span><span class="k">async</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">async</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">_obj</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">_latestValue</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">_ref</span><span class="p">.</span><span class="nx">markForCheck</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Jak widaÄ‡ powyÅ¼ej, w momencie aktualizacji wartoÅ›ci wywoÅ‚ywana jest funkcja markForCheck(), ktÃ³ra powiadamia mechanizm detekcji zmian o koniecznoÅ›ci sprawdzenia danego komponentu.</p>

<h2 id="przejÄ™cie-kontroli-nad-mechanizmem-detekcji-zmian">PrzejÄ™cie kontroli nad mechanizmem detekcji zmian</h2>
<p>Co w przypadku, gdy bardzo potrzebujemy uÅ¼yÄ‡ funkcji setInterval lub setTimeout, ale jednoczeÅ›nie chcielibyÅ›my rÃ³wnieÅ¼ uÅ¼ywaÄ‡ strategii onPush? Angular daje nam moÅ¼liwoÅ›Ä‡ wstrzykniÄ™cia dedykowanego ChangeDetectora danemu komponentowi, a potem wywoÅ‚anie na nim funkcji markForCheck() - analogicznie jak w opisywanym przykÅ‚adzie z AsyncPipe!
PrzykÅ‚adowy kod wyglÄ…daÅ‚by tak:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">constructor</span><span class="p">(</span><span class="k">private</span> <span class="nx">cowService</span><span class="p">:</span> <span class="nx">CowService</span><span class="p">,</span> <span class="k">private</span> <span class="nx">changeDetectorRef</span><span class="p">:</span> <span class="nx">ChangeDetectorRef</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">updateCowDonationWithTimeout</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">private</span> <span class="nx">updateCowDonationWithTimeout</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">cowDonation</span> <span class="o">=</span> <span class="p">{</span>
            <span class="na">donation</span><span class="p">:</span> <span class="mi">500</span>
        <span class="p">};</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">changeDetectorRef</span><span class="p">.</span><span class="nx">markForCheck</span><span class="p">();</span>
    <span class="p">},</span> <span class="mi">500</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Przy stworzeniu komponentu zostanie wywoÅ‚ana funkcja zmieniajÄ…ca wartoÅ›Ä‡ dotacji dla krowy na 500 po upÅ‚ywie okoÅ‚o 500ms, a wszystko dziÄ™ki wywoÅ‚aniu markForCheck() na referencji do detektora zmian komponentu.</p>

<h2 id="na-co-naleÅ¼y-uwaÅ¼aÄ‡">Na co naleÅ¼y uwaÅ¼aÄ‡?</h2>
<p>Przypomnijmy, Å¼e przy korzystaniu ze strategii onPush musimy pamiÄ™taÄ‡ o tym, Å¼e:</p>
<ul>
  <li>zmiany inputÃ³w komponentu muszÄ… zachodziÄ‡ poprzez zmianÄ™ referencji, a nie wartoÅ›ci!</li>
  <li>funkcje asynchroniczne (setTimeout, setInterval, manualna subskrypcja do Observableâ€™a) nie wywoÅ‚ujÄ… mechanizmu detekcji zmian.</li>
</ul>

<h2 id="kilka-sÅ‚Ã³w-na-zakoÅ„czenie">Kilka sÅ‚Ã³w na zakoÅ„czenie</h2>
<p>OnPush wymusza na nas projektowanie komponentÃ³w w okreÅ›lony sposÃ³b - tak, Å¼eby komponent odpowiedzialny byÅ‚ jedynie za prezentacjÄ™ danych na podstawie otrzymanych inputÃ³w. CaÅ‚a skomplikowana logika mogÅ‚aby wtedy byÄ‡ przeniesiona do serwisÃ³w. Przeniesienie logiki do serwisu umoÅ¼liwiÅ‚oby teÅ¼ Å‚atwiejsze otestowanie kodu - fajnie jest mieÄ‡ jakieÅ› potwierdzenie, Å¼e nasz kod robi to, co powinien :). Pisanie komponentÃ³w niezmienialnych (ang. immutable) i ogÃ³Å‚em kodu opartego na niezmienialnoÅ›ci to tworzenie dobrych przyzwyczajeÅ„, ktÃ³re mogÄ… byÄ‡ wykorzystane przy adaptacji nowych rozwiÄ…zaÅ„ w projekcie - przykÅ‚adowo kontrolowanie stanu z wykorzystaniem biblioteki ngRx, ktÃ³ra rÃ³wnieÅ¼ wymusza na programistach pisanie kodu opartego na niezmienialnoÅ›ci. Stosowanie strategii onPush z pewnoÅ›ciÄ… moÅ¼e zwiÄ™kszyÄ‡ wydajnoÅ›Ä‡ aplikacji, choÄ‡ zalecaÅ‚bym korzystanie z tej strategii w nowo tworzonych komponentach, pisanych od poczÄ…tku z myÅ›lÄ… o niezmienialnoÅ›ci. Wprowadzanie onPushâ€™a na siÅ‚Ä™ do juÅ¼ istniejÄ…cych, czasami mocno rozbudowanych komponentÃ³w moÅ¼e doprowadziÄ‡ do niepoÅ¼Ä…danych zachowaÅ„ (a w tym przypadku braku reakcji na zmiany :P), wiÄ™c trzeba wziÄ…Ä‡ to pod uwagÄ™ adaptujÄ…c tÄ™ strategiÄ™ do juÅ¼ istniejÄ…cego kodu.</p>
:ET