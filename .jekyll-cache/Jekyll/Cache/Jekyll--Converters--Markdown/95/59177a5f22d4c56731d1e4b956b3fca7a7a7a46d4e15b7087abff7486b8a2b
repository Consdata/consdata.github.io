I"3%<p>Czasem zachodzi potrzeba uzależnienia pozycji elementu od scrolla okna, czy to na potrzeby przyklejenia w widocznym obszarze, czy też stworzenia efektu paralaksy lub niestandardowego flow nawigacji. Temat wydawałby się oczywisty, gdyby nie to, że celowo wprowadzimy sobie dodatkowe ograniczenia (co wcale nie jest takie niecodziennie, uwzględniając fantazję działów UI/UX ;-)).</p>

<h2 id="podejście-1-tylko-css">Podejście 1: tylko CSS</h2>
<p>Mamy dwa sposoby przyklejenia elementu do ekranu wykorzystujące tylko CSS. Oba opierają się o zmianę pozycjonowania:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">position: fixed</code>,</li>
  <li><code class="language-plaintext highlighter-rouge">position: sticky</code>.</li>
</ul>

<p>Oba też mają swoje problemy i ograniczenia.</p>

<p>Stosując pozycjonowanie fixed:</p>
<ul>
  <li>musimy uwzględnić pozostawione przez niego miejsce w oryginalnym fragmencie drzewa DOM,</li>
  <li>jeżeli element będzie wyższy niż viewport to nie będziemy mieli możliwości obejrzeć niemieszczącej się zawartości,</li>
  <li>fixed zawsze tworzy nowy stacking context.</li>
</ul>

<p>Stosując pozycjonowanie sticky:</p>
<ul>
  <li>jeżeli element będzie wyższy niż viewport, to nie będziemy mieli możliwości obejrzeć niemieszczącej się zawartości,</li>
  <li>sticky zawsze tworzy nowy stacking context,</li>
  <li>sticky czasem może zaskoczyć swoim działaniem (przykładowo <a href="https://github.com/w3c/csswg-drafts/issues/865">issue w3c</a>).</li>
</ul>

<p>O ile uwzględnienie oderwanego przez fixed elementu w layoucie nie stanowi wyzwania, o tyle brak wsparcia dla przewijania treści i zmiana stacking context (co wpłynie np. na liczenie kolejności na osi z) mogą stanowić już zbyt duże ograniczenia.</p>

<p>W wielu przypadkach fixed lub sticky załatwią problem. Jeśli jednak potrzebujesz czegoś więcej, czytaj dalej.</p>

<h2 id="podejście-2-javascript">Podejście 2: JavaScript</h2>
<p>„Nie ma takiej rzeczy, której bym nie napisał w JavaScript.” 😉</p>

<p>Przeglądarki oferują nam zdarzenie związane ze scrollowaniem treści. Na zdarzenie możemy nasłuchiwać przez zdefiniowanie własności <code class="language-plaintext highlighter-rouge">target.onscroll</code>, czy też bardziej elastycznie, dodając listener przez <code class="language-plaintext highlighter-rouge">target.addEventListner(’scroll’)</code>. Teoretycznie wystarczyłoby już tylko przeliczać pozycję przyklejanego elementu, obsłużyć przewijanie w dwóch kierunkach i nie zapomnieć o użyciu najmniej obciążającej metody przesuwania elementów po ekranie. Co może pójść źle? Sprawdźmy prosty przykład.</p>

<p>Implementujemy proste przeliczanie pozycji nasłuchując na zdarzenie scroll:</p>

<iframe width="100%" height="300" src="//jsfiddle.net/gregorry/gof6we57/embedded/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>

<p>Uzyskany efekt:</p>
<iframe class="youtube" src="https://www.youtube.com/embed/86dZ7HguQWY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>Okazuje się, że funkcjonalnie możemy uzyskać wszystko, czego potrzebujemy, jednak jakość rozwiązania nie jest zadowalająca. Gdy przyjrzymy się sprawie bliżej, zauważymy, że na różnych przeglądarkach mamy różne problemy z płynnym rysowaniem UI. Obserwujemy lekki pościg naszego elementu względem reszty strony - to stanowczo nie jest efekt, z którym chcemy być kojarzeni.</p>

<p>Możemy jeszcze raz przeanalizować nasze kody, przekonać się, że ani throttlowanie zdarzeń, ani przesuwanie transformem, ani nawet wymyślne funkcje wygładzające nic nie dają. Okazuje się, że odpowiedź jest równocześnie dobra i zła, dobra - bo z naszym kodem nie ma większych problemów; zła - bo tak po prostu działają przeglądarki, na co niespecjalnie mamy wpływ!</p>

<p>Całe zamieszanie wynika z tego, że większość nowoczesnych przeglądarek obsługuje rysowanie oraz scrollowanie w osobnych wątkach. W praktyce oznacza to, że pozycja strony oraz jej zawartość liczone są w różnych momentach. Brak synchronizacji na tych operacjach objawia się skakaniem przesuwanego elementu. O ile takie rozwiązanie ułatwia przeglądarkom uzyskiwać upragnione 60 fps przy renderowaniu, o tyle dla nas oznacza skreślenie tego rozwiązania z listy wartościowych.</p>

<h2 id="co-dalej">Co dalej?</h2>
<p>Czy to oznacza, że jeśli rozwiązanie z pozycjonowaniem CSS oferuje za mało funkcjonalności, a na lag przy rysowaniu z JavaScript nie możemy sobie pozwolić, to musimy rozłożyć ręce? Oczywiście, że nie! Na początek chwyćmy się wyjaśnienia z poprzednich akapitów - problemem jest, że scroll viewportu i DOM strony rysowane są niezależnie, w różnych momentach czasu. Gdybyśmy jednak potrafili zapewnić, że obie te rzeczy będą się działy synchronicznie? O ile nie możemy do tego zmusić przeglądarki, o tyle możemy ją oszukać 😉</p>

<p>Załóżmy że:</p>
<ul>
  <li>to nie przeglądarka odpowiada za przewijanie treści strony,</li>
  <li>scroll przeglądarki wyraża jedynie intencję, w którym miejscu strona ma się znajdować,</li>
  <li>faktyczne przesuwanie treści odbywa się w naszym kodzie,</li>
  <li>również w naszym kodzie znajduje się obsługa przesuwania przyklejonych elementów,</li>
  <li>obliczenia wykonujemy co żądanie klatki animacji.</li>
</ul>

<p>Przy takich założeniach możliwe okazuje się uzyskanie płynnego przewijania i przyklejania elementów. Dodatkowo, proponowane rozwiązanie poza przyklejaniem pierwszy raz oferuje opcję realizacji paralaksy czy niestandardowych przejść strony (kto powiedział, że kolejne ekrany nie mają być po skosie lub na spirali ;-)).</p>

<h2 id="rozwiązanie">Rozwiązanie</h2>
<p>Przykładowe rozwiązanie może wyglądać następująco:</p>
<ul>
  <li>dotychczasową strukturę DOM opakowujemy we wrapper,</li>
  <li>wrapper pozycjonujemy jako fixed na cały ekran (<code class="language-plaintext highlighter-rouge">top, bottom, left, right</code> na 0),
    <ul>
      <li>to będzie nadrzędny element strony odpowiedzialny za prezentowanie viewport, w tym obsługę przewijania,</li>
    </ul>
  </li>
  <li>obok wrappera definiujemy sztuczny element replikujący wysokość wrappera,
    <ul>
      <li>to będzie element odpowiedzialny za symulowanie wysokości strony, dzięki niemu przeglądarka będzie wyświetlała prawidłowy pasek przewijania i poprawnie rozgłaszała związane z nim zdarzenia,</li>
    </ul>
  </li>
  <li>definiujemy metodę renderującą ekran co klatkę animacji,
    <ul>
      <li>odpowiada za faktycznie rysowanie pozycji elementów, zarówno standardowo przewijanej zawartości, jak i przyklejonych elementów,</li>
    </ul>
  </li>
  <li>zawartość wrappera przewijamy zgodnie z bieżącym scrollem,</li>
  <li>przyklejony element przewijamy odwrotnie, kompensując przesunięcie wrappera.</li>
</ul>

<p>Przykładowa implementacja</p>

<iframe width="100%" height="300" src="//jsfiddle.net/gregorry/yatd97hv/embedded/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>

<p>Przedstawione rozwiązanie jest najprostszym z możliwych potwierdzających teoretyczne założenia.</p>

<p>W docelowym rozwiązaniu na pewno warto pomyśleć o rozdzieleniu funkcji pętli od faktycznego rysowania, wygładzaniu przesunięcia scrolla, dorzuceniu wskazówki <code class="language-plaintext highlighter-rouge">will-change</code> dla przesuwanych elementów, czy ogólnym sposobie na nasłuchiwanie na zmiany scrolla globalnie.</p>

<p>Po wprowadzeniu zmian nasz rozwiązanie prezentuje się znacznie lepiej:</p>
<iframe class="youtube" src="https://www.youtube.com/embed/GqopRJ1vuC8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<h2 id="sukces">Sukces?</h2>
<p>Samodzielna obsługa scrollowania może być kusząca przy realizacji niestandardowych przepływów ekranów, animacji, czy skomplikowanych interfejsów użytkownika. Zawsze jednak należy pamiętać, że przerzucamy na własną implementację ciężar obsługi czegoś, co jest robione dobrze przez każdą przeglądarkę. Czasem lepszym rozwiązaniem będzie znalezienie uproszczeń w wymaganiach, a czasem będziemy mogli wziąć na siebie takie trade-off 🙂</p>

<p>Czy ktoś stosuje takie podejścia? Tak, przykładem niech będzie apple.com, gdzie przewijane początkowo jest pionowe, następnie poziome i na końcu znowu pionowe 😉</p>
<iframe class="youtube" src="https://www.youtube.com/embed/wMdNDHM2wrc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<h2 id="przydatne-linki">Przydatne linki</h2>
<ul>
  <li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Scroll-linked_effects">Scroll-linked effects @ MDN</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context">The stacking context</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position">Własności pozycjonowania elementów drzewa DOM @ MDN</a></li>
  <li><a href="https://philipwalton.com/articles/what-no-one-told-you-about-z-index/">What No One Told You About Z-Index</a></li>
</ul>
:ET