I"ò-<p>Tomcat jest jednym z najpopularniejszych serwerÃ³w webowych dla aplikacji pisanych w Javie. Jest podstawowym kontenerem aplikacji springbootowych. TworzÄ…c nowy projekt czÄ™sto polegamy na jego domyÅ›lnej konfiguracji. Kiedy projekt dojrzewa do wdroÅ¼enia produkcyjnego i musi zmierzyÄ‡Â siÄ™ z obsÅ‚ugÄ… duÅ¼ego ruchu, czÄ™sto konieczne okazuje siÄ™Â dostrojenie tej konfiguracji. W tym artykule skupiÄ™Â siÄ™Â na konfiguracji connectorÃ³w na przykÅ‚adzie pewnego problemu produkcyjnego. Opis konfiguracji Tomcata bazuje na wersji 7.x, ale jest w zasadzie aktualny rÃ³wnieÅ¼ dla wyÅ¼szych wersji.</p>

<h2 id="problem-z-wyczerpanÄ…-pulÄ…-wÄ…tkÃ³w-w-tomcacie">Problem z wyczerpanÄ… pulÄ… wÄ…tkÃ³w w Tomcacie</h2>

<p>W jednym z systemÃ³w, ktÃ³re wspÃ³Å‚tworzyÅ‚em, wystÄ…piÅ‚ problem podczas dziaÅ‚ania produkcyjnego. Problem objawiaÅ‚ siÄ™Â brakiem moÅ¼liwoÅ›ci poÅ‚Ä…czenia z endpointem wystawionym na Tomcacie. Monitoring i analiza logÃ³w jednoznacznie pokazaÅ‚y, Å¼e wyczerpaÅ‚a siÄ™ pula wÄ…tkÃ³w obsÅ‚ugujÄ…cych Å¼Ä…dania http. Dalsza analiza ujawniÅ‚a, Å¼e praprzyczynÄ… problemu byÅ‚ w tym przypadku system autoryzacji, z ktÃ³rym Å‚Ä…czyÅ‚Â siÄ™ nasz system. W systemie autoryzacji znaczÄ…co wzrosÅ‚y czasy odpowiedzi, co powodowaÅ‚o, Å¼e wÄ…tki Tomcata byÅ‚y bardzo dÅ‚ugo zajÄ™te. Tomcat powoÅ‚ywaÅ‚ nowe wÄ…tki, ale ostatecznie osiÄ…gnÄ…Å‚ limit 1000 wÄ…tkÃ³w (taki mieliÅ›my ustawiony na connectorze) i przestaÅ‚ obsÅ‚ugiwaÄ‡ nowe poÅ‚Ä…czenia - rÃ³wnieÅ¼ takie, ktÃ³re nie wymagaÅ‚y wywoÅ‚ania systemu autoryzacji.</p>

<p>Co wiÄ™cej, zauwaÅ¼yliÅ›my i potwierdziliÅ›my to pÃ³Åºniej w testach, Å¼e po caÅ‚kowitym wysyceniu puli wÄ…tkÃ³w, Tomcat nie jest w stanie bez restartu powrÃ³ciÄ‡ do prawidÅ‚owego dziaÅ‚ania nawet wtedy, kiedy problem z dÅ‚ugimi czasami odpowiedzi zostanie wyeliminowany.</p>

<p>Opisana sytuacja skÅ‚oniÅ‚a nas do sprawdzenia czy jesteÅ›my w stanie zapobiec takiemu zachowaniu Tomcata poprzez modyfikacjÄ™Â konfiguracji connectorÃ³w. PojawiÅ‚Â siÄ™ miÄ™dzy innymi pomysÅ‚ zmiany implementacji connectora blokujÄ…cego (bio) na nieblokujÄ…cy (nio). W systemie, ktÃ³rego dotyczyÅ‚Â problem uÅ¼ywany byÅ‚ tomcat 7.x, w ktÃ³rym domyÅ›lnie uÅ¼ywana jest implementacja blokujÄ…ca.</p>

<h2 id="konfiguracja-connectorÃ³w">Konfiguracja connectorÃ³w</h2>

<p>Podstawowa konfiguracja Tomcata znajduje siÄ™Â w pliku conf/server.xml i zawiera konfiguracjÄ™ nastÄ™pujÄ…cych elementÃ³w:</p>
<ul>
  <li><a href="http://tomcat.apache.org/tomcat-7.0-doc/config/server.html">Server</a> - konfiguracja caÅ‚ego kontenera, zawiera konfiguracje poszczegÃ³lnych serwisÃ³w.</li>
  <li><a href="http://tomcat.apache.org/tomcat-7.0-doc/config/service.html">Service</a> - zawiera konfiguracjÄ™ poszczegÃ³lnych connectorÃ³w Å‚Ä…czÄ…c je silnikiem przetwarzania Å¼Ä…daÅ„.</li>
  <li><a href="http://tomcat.apache.org/tomcat-7.0-doc/config/http.html">Connector</a> - nasÅ‚uchuje na wybranym porcie http i obsÅ‚uguje poÅ‚Ä…czenia przekazujÄ…c Å¼Ä…dania do silnika zdefiniowanego w elemencie Engine.</li>
  <li><a href="http://tomcat.apache.org/tomcat-7.0-doc/config/engine.html">Engine</a> - przetwarza Å¼Ä…dania pochodzÄ…ce ze wszystkich connectorÃ³w zdefiniowanych w elemencie Service.</li>
</ul>

<p>Z punktu widzenia przetwarzania Å¼Ä…daÅ„, kluczowe znaczenie ma konfiguracja connectora i parametry:</p>
<ul>
  <li>protocol - Pozwala okreÅ›liÄ‡ wybranÄ… implementacjeÂ connectora (to tutaj moÅ¼emy zdecydowaÄ‡ czy chcemy uÅ¼yÄ‡ connectora blokujÄ…cego czy nieblokujÄ…cego).</li>
  <li>acceptCount - DÅ‚ugoÅ›Ä‡Â kolejki oczekujÄ…cych poÅ‚Ä…czeÅ„. Kolejka napeÅ‚nia siÄ™Â jeÅ¼eli wszystkie wÄ…tki w puli wÄ…tkÃ³w connectora sÄ… zajÄ™te. W przypadku osiÄ…gniÄ™cia limitu tej kolejki (domyÅ›lnie 100) poÅ‚Ä…czenia klientÃ³w bÄ™dÄ… odrzucane.</li>
  <li>maxConnections - Maksymalna liczba poÅ‚Ä…czeÅ„, ktÃ³re mogÄ… byÄ‡Â przetwarzane. Po osiÄ…gniÄ™ciu maksymalnej liczby poÅ‚Ä…czeÅ„, poÅ‚Ä…czenia nadal sÄ… przyjmowane i kolejkowane do czasu osiÄ…gniÄ™cia limitu wynikajÄ…cego z parametru acceptCount. DomyÅ›lnie maxConnections jest rÃ³wne maxThreads dla connectora blokujÄ…cego i 10000 dla nieblokujÄ…cego.</li>
  <li>maxThreads - Maksymalna liczba wÄ…tkÃ³w obsÅ‚ugujÄ…cych Å¼Ä…dania. Parametr ten oznacza, ile Å¼Ä…daÅ„Â moÅ¼e byÄ‡Â symultanicznie przetwarzanych przez serwer. DomyÅ›lna wartoÅ›Ä‡ tego parametru to 200. Jest to najwaÅ¼niejszy parametr, zwaÅ¼ywszy na problem, ktÃ³ry rozwiÄ…zujemy w tym artykule.</li>
</ul>

<h2 id="monitorowanie-puli-wÄ…tkÃ³w">Monitorowanie puli wÄ…tkÃ³w</h2>

<p>Aktualna liczba wÄ…tkÃ³w przetwarzajÄ…cych Å¼Ä…dania jest, obok rozmiaru sterty, jednym z najwaÅ¼niejszych parametrÃ³w, ktÃ³re powinny byÄ‡ objÄ™te monitoringiem. W tym przypadku monitorujemy atrybut <code class="language-plaintext highlighter-rouge">currentThreadsBusy</code> mbeanâ€™a</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Catalina:name="http-RODZAJ_CONNECTORA-PORT",type=ThreadPool
</code></pre></div></div>
<p>(przy czym RODZAJ_CONNECTORA to â€œbioâ€ dla connectora blokujÄ…cego i â€œnioâ€ dla nieblokujÄ…cego, PORT to numer portu, na ktÃ³rym nasÅ‚uchuje connector).</p>

<p>Do monitoringu moÅ¼na uÅ¼yÄ‡ narzÄ™dzia <a href="https://jolokia.org/">jolokia</a>, ktÃ³re udostÄ™pnia JMX za pomocÄ… protokoÅ‚u http. W takiej konfiguracji wystarczy regularnie odpytywaÄ‡ o stan puli wÄ…tkÃ³w poprzez wywoÅ‚anie http GET:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://HOST:PORT/jolokia/read/Catalina:name="http-RODZAJ_CONNECTORA-PORT",type=ThreadPool/currentThreadsBusy
</code></pre></div></div>

<p>W odpowiedzi dostajemy jsona, ktÃ³ry w polu value zawiera aktualny rozmiar puli wÄ…tkÃ³w</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"request"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"mbean"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Catalina:name=</span><span class="se">\"</span><span class="s2">http-RODZAJ_CONNECTORA-PORT</span><span class="se">\"</span><span class="s2">,type=ThreadPool"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"attribute"</span><span class="p">:</span><span class="w"> </span><span class="s2">"currentThreadsBusy"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"read"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"value"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="nl">"timestamp"</span><span class="p">:</span><span class="w"> </span><span class="mi">1564763927</span><span class="p">,</span><span class="w">
  </span><span class="nl">"status"</span><span class="p">:</span><span class="w"> </span><span class="mi">200</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>Warto skonfigurowaÄ‡Â alerting, ktÃ³ry bÄ™dzie ostrzegaÅ‚ o wysycaniu siÄ™ puli poÅ‚Ä…czeÅ„ i pozwoli szybciej zdiagnozowaÄ‡Â problem.</p>

<h2 id="porÃ³wnanie-connectorÃ³w-blokujÄ…cych-bio-i-nieblokujÄ…cych-nio">PorÃ³wnanie connectorÃ³w blokujÄ…cych (bio) i nieblokujÄ…cych (nio)</h2>

<h3 id="rÃ³Å¼nica-w-dziaÅ‚aniu">RÃ³Å¼nica w dziaÅ‚aniu</h3>

<p>W Tomcacie 7.x domyÅ›lnÄ…Â implementacjÄ…Â connectora jest implementacja blokujÄ…ca. W Tomcacie 8 i wyÅ¼szych domyÅ›lny jest connector nieblokujÄ…cy. Podstawowa rÃ³Å¼nica w dziaÅ‚aniu polega na tym, Å¼e <strong>w connectorze blokujÄ…cym wÄ…tek przypisywany jest do poÅ‚Ä…czenia, a w connectorze nieblokujÄ…cym do pojedynczego Å¼Ä…dania</strong>. MoÅ¼e to mieÄ‡ duÅ¼e znaczenie przy zastosowaniu poÅ‚Ä…czeÅ„ keep-alive, kiedy to jedno poÅ‚Ä…czenie jest wykorzystywane do przesÅ‚ania wielu Å¼Ä…daÅ„Â i odpowiedzi. W takim modelu wÄ…tek na serwerze jest zajÄ™ty na caÅ‚y czas trwania pojedynczego poÅ‚Ä…czenia mimo, Å¼e faktyczne przetwarzanie na serwerze zachodzi tylko w obrÄ™bie pojedynczego Å¼Ä…dania.</p>

<h3 id="test">Test</h3>

<p>Dla porÃ³wnania moÅ¼na wykonaÄ‡ prosty test na dwÃ³ch rodzajach connectorÃ³w. W teÅ›cie klient raz na sekundÄ™ wysyÅ‚a Å¼Ä…danie do serwera. ÅÄ…cznie jeden klient wysyÅ‚a 30 Å¼Ä…daÅ„. Uruchamiamy 20 klientÃ³w w ciÄ…gu 2 sekund. JednoczeÅ›nie monitorujemy rozmiar puli wÄ…tkÃ³w.</p>

<p>Tak wyglÄ…da wykres czasÃ³w odpowiedzi dla connectora blokujÄ…cego:</p>

<p><img src="/assets/img/posts/2020-03-18-tomcat-model-przetwarzania-zadan/gatling-bio.png" alt="wykres czasÃ³w odpowiedzi dla connectora blokujÄ…cego" /></p>

<p>a tak dla connectora nieblokujÄ…cego:</p>

<p><img src="/assets/img/posts/2020-03-18-tomcat-model-przetwarzania-zadan/gatling-nio.png" alt="wykres czasÃ³w odpowiedzi dla connectora nieblokujÄ…cego" /></p>

<p>Nie widaÄ‡ tutaj jakiejÅ› specjalnej rÃ³Å¼nicy miÄ™dzy dziaÅ‚aniem connectora bio i nio. ZupeÅ‚nie inaczej wyglÄ…dajÄ… natomiast wykresy liczby zajÄ™tych wÄ…tkÃ³w w puli. Dla connectora blokujÄ…cego liczba zajÄ™tych wÄ…tkÃ³w podczas trwania testu przekracza 20. Czyli jest zgodna z liczbÄ… klientÃ³w wysyÅ‚ajÄ…cych Å¼Ä…dania do serwera. PoÅ‚Ä…czenia keep-alive majÄ… timeout rÃ³wny 5 sekund wiÄ™c klient utrzymuje caÅ‚y czas jedno poÅ‚Ä…czenie do wszystkich Å¼Ä…daÅ„:</p>

<p><img src="/assets/img/posts/2020-03-18-tomcat-model-przetwarzania-zadan/threads-bio.png" alt="wykres liczby zajÄ™tych wÄ…tkÃ³w dla connectora blokujÄ…cego" /></p>

<p>Dla connectora nieblokujÄ…cego Å¼Ä…dania sÄ… obsÅ‚ugiwane w wiÄ™kszoÅ›ci przez jeden wÄ…tek:</p>

<p><img src="/assets/img/posts/2020-03-18-tomcat-model-przetwarzania-zadan/threads-nio.png" alt="wykres liczby zajÄ™tych wÄ…tkÃ³w dla connectora nieblokujÄ…cego" /></p>

<p>Test pokazuje, Å¼e przy takim modelu przetwarzania Å¼Ä…daÅ„ za pomocÄ…Â connectora nieblokujÄ…cego moÅ¼emy uzyskaÄ‡ sporÄ… oszczÄ™dnoÅ›Ä‡Â zasobÃ³w i lepiej zutylizowaÄ‡ serwer.</p>

<h3 id="uÅ¼ycie-mod_proxy-zmienia-sytuacjÄ™">UÅ¼ycie mod_proxy zmienia sytuacjÄ™</h3>

<p>Warto zwrÃ³ciÄ‡ uwagÄ™ na to, Å¼e takie wyniki osiÄ…gamy w przypadku bezpoÅ›redniego poÅ‚Ä…czenia pomiÄ™dzy klientem, a serwerem Tomcat. Zdarza siÄ™Â jednak, Å¼e mamy jeszcze warstwÄ™ poÅ›redniÄ… np. w postaci serwera Apache httpd i moduÅ‚u mod_proxy. DomyÅ›lnie mod_proxy nie ma wÅ‚Ä…czonej opcji keep-alive wiÄ™c wszystkie poÅ‚Ä…czenia do backendu sÄ… zamykane po obsÅ‚uÅ¼eniu pojedynczego Å¼Ä…dania.</p>

<p>Test zostaÅ‚ przeprowadzony za pomocÄ… narzÄ™dzia <a href="https://gatling.io/">Gatling</a>. WiÄ™cej o samym narzÄ™dziu moÅ¼na przeczytaÄ‡ w osobnym <a href="/2017/08/01/gatling.html">artykule na naszym blogu</a>.</p>

<h2 id="prÃ³ba-rozwiÄ…zania-problemu">PrÃ³ba rozwiÄ…zania problemu</h2>

<p>PodsumowujÄ…c: WstÄ™pem do rozwaÅ¼aÅ„ nad konfiguracjÄ…Â connectorÃ³w byÅ‚ problem z dÅ‚ugimi czasami jakie wÄ…tki Tomcata spÄ™dzaÅ‚y na komunikacji z systemem autoryzacji. Czy zmiana connectora na nieblokujÄ…cy pomogÅ‚aby w tej sytuacji? Niestety nie. Connector nieblokujÄ…cy nie wiÄ…Å¼e wÄ…tku z poÅ‚Ä…czeniem, ale nadal wiÄ…Å¼e go z pojedynczym Å¼Ä…daniem. W tym przypadku nadal wÄ…tki bÄ™dÄ… blokowane na dÅ‚ugim wywoÅ‚aniu systemu autoryzacji. ChoÄ‡Â zastosowanie connectora nio z pewnoÅ›ciÄ… zaoszczÄ™dziÅ‚oby czÄ™Å›Ä‡ zasobÃ³w maszyny, to w tym przypadku naleÅ¼aÅ‚oby raczej rozwaÅ¼yÄ‡ uÅ¼ycie jakiejÅ›Â implementacji circuit breakerâ€™a lub teÅ¼ zmieniÄ‡ model obsÅ‚ugi Å¼Ä…daÅ„ na bardziej reaktywny (np. <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html">webflux</a>).</p>
:ET