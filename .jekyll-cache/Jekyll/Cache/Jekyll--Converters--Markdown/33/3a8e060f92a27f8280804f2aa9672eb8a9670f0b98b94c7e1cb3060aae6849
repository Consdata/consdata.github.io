I"Œ-<p>Z programem Wireshark pierwszy raz zetknÄ…Å‚em siÄ™ w czasie studiÃ³w na zajÄ™ciach z sieci komputerowych (dla niewtajemniczonych: Wireshark to aplikacja ktÃ³ra umoÅ¼liwia przechwytywanie i nagrywanie pakietÃ³w danych, a takÅ¼e ich dekodowanie i analizowanie). WÃ³wczas odniosÅ‚em wraÅ¼enie Å¼e jest to narzÄ™dzie stricte dla administratorÃ³w sieci i nie ma wiÄ™kszego zastosowania w obszarze wytwarzania i utrzymywania oprogramowania.</p>

<p>Z upÅ‚ywem czasu zrozumiaÅ‚em Å¼e tworzenie systemÃ³w to nie tylko pisanie piÄ™knego i czystego kodu, ale takÅ¼e dÅ‚ugie godziny spÄ™dzone na debugowaniu bÅ‚Ä™dÃ³w i analizowaniu problemÃ³w. W wielu sytuacjach kluczowa jest moÅ¼liwoÅ›Ä‡ podejrzenia komunikatÃ³w przesyÅ‚anych miÄ™dzy elementami systemu. Do tego wÅ‚aÅ›nie Å›wietnie sprawdziÅ‚o siÄ™ narzÄ™dzie poznane na studiach.</p>

<p>PoniÅ¼ej pokaÅ¼Ä™ przykÅ‚adowe sytuacje w ktÃ³rych wykorzystaÅ‚em Wiresharka, Å¼eby dotrzeÄ‡ do sedna analizowanego problemu.</p>

<h2 id="dlaczego-serwisy-siÄ™-nie-dogadujÄ…">â€œDlaczego serwisy siÄ™ nie dogadujÄ…?â€</h2>
<p>JakiÅ› czas temu pracowaÅ‚em przy utrzymaniu systemu zrealizowanego w architekturze rozproszonej, ktÃ³rego moduÅ‚y komunikowaÅ‚y siÄ™ za pomocÄ… RESTa. Niestety logi aplikacyjne nie zawsze byÅ‚y wystarczajÄ…co szczegÃ³Å‚owe. W pewnym przypadku dostawaliÅ›my w logach wpisy postaci:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>12:33:52.823 [main] DEBUG org.springframework.web.client.RestTemplate - GET request for "http://172.19.57.4:8080/fin2/acc/balance?accNum=93%201090%200088%205180%205697%201019%203200" resulted in 500 (null); invoking error handler
Exception in thread "main" org.springframework.web.client.HttpServerErrorException: 500 null
    at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:94)
    at org.springframework.web.client.RestTemplate.handleResponse(RestTemplate.java:667)
    at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:620)
    at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:580)
    at org.springframework.web.client.RestTemplate.getForObject(RestTemplate.java:287)
    at com.brdg.fin2.acc.AccClient.getBalance(AccClient.java:175)
</code></pre></div></div>
<p>Same logi niewiele mÃ³wiÅ‚y, poza tym Å¼e serwer nie radzi sobie z obsÅ‚ugÄ… Å¼Ä…dania. Serwer raportowaÅ‚ konkretnÄ… przyczynÄ™ niepowodzenia w treÅ›ci odpowiedzi, jednak ta nie byÅ‚a logowana na kliencie. W takiej sytuacji analiza Wiresharkiem pozwoliÅ‚a szybko ustaliÄ‡ co faktycznie byÅ‚o nie tak:</p>
<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">GET</span> <span class="nn">/fin2/acc/balance?accNum=93%201090%200088%205180%205697%201019%203200</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Accept</span><span class="p">:</span> <span class="s">text/plain, application/json, application/*+json, */*</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Java/1.8.0_111</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">172.19.57.4:8080</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">keep-alive</span>

HTTP/1.1 500
X-Application-Context: application:8080
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Connection: close

b5
{"status":500,"error":"Internal Server Error","exception":"java.lang.NumberFormatException","message":"For input string: \"93 10\"","path":"/fin2/acc/balance"}
0
</code></pre></div></div>
<p>W tym przypadku usuniÄ™cie spacji z numeru rachunku pozwoliÅ‚o wyeliminowaÄ‡ problem.</p>

<h2 id="przecieÅ¼-podajÄ™-ten-parametr-o-tu">â€œPrzecieÅ¼ podajÄ™ ten parametr, o tu!â€</h2>
<p>Zdarza siÄ™, Å¼e pisanie nowego kodu idzie gÅ‚adko, aÅ¼ napotykamy na sytuacjÄ™, w ktÃ³rej wydaje nam siÄ™ Å¼e wszystko dobrze zakodowaliÅ›my, a jednak serwer twierdzi Å¼e wysyÅ‚ane przez nas Å¼Ä…danie jest niepoprawne. PrzykÅ‚ad kodu klienta RESTowej usÅ‚ugi, ktÃ³ry wydawaÅ‚ mi siÄ™ poprawny:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">WebTarget</span> <span class="n">webTarget</span> <span class="o">=</span> <span class="n">createWebTarget</span><span class="o">();</span>
<span class="n">webTarget</span><span class="o">.</span><span class="na">queryParam</span><span class="o">(</span><span class="s">"statementNo"</span><span class="o">,</span> <span class="n">statementNumber</span><span class="o">);</span>
<span class="nc">Response</span> <span class="n">response</span> <span class="o">=</span> <span class="n">webTarget</span><span class="o">.</span><span class="na">request</span><span class="o">().</span><span class="na">get</span><span class="o">();</span>
</code></pre></div></div>
<p>A jednak serwer uporczywie twierdziÅ‚ Å¼e:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Required String parameter 'statementNo' is not present.
</code></pre></div></div>
<p>WyglÄ…daÅ‚o jakby serwer nie potrafiÅ‚ odczytaÄ‡ wysyÅ‚anego przeze mnie parametru. Zanim jednak zaczÄ…Å‚em obwiniaÄ‡ stronÄ™ serwerowÄ…, postanowiÅ‚em upewniÄ‡ siÄ™ Å¼e Å¼Ä…danie HTTP w istocie jest poprawne. Szybka analiza Wiresharkiem pokazaÅ‚a:</p>
<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">GET</span> <span class="nn">/crwr/statement</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Jersey/2.23.2 (HttpUrlConnection 1.8.0_79)</span>
<span class="na">Accept</span><span class="p">:</span> <span class="s">text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">keep-alive</span>

HTTP/1.1 400
...
</code></pre></div></div>

<p>Chwila, a gdzie mÃ³j parametr? MajÄ…c pewnoÅ›Ä‡, Å¼e problem leÅ¼y jednak po stronie klienckiej, zaczÄ…Å‚em wnikliwiej analizowaÄ‡ kod linijka po linijce (tym razem czytajÄ…c javadoki JAX-RS :) ) :</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
* Create a new {@code WebTarget} instance by configuring a query parameter on the URI
* of the current target instance.
* ...
* @return a new target instance.
* ...
*/</span>
<span class="kd">public</span> <span class="nc">WebTarget</span> <span class="nf">queryParam</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">Object</span><span class="o">...</span> <span class="n">values</span><span class="o">);</span>
</code></pre></div></div>
<p>No cÃ³Å¼, przynajmniej mam teraz o czym pisaÄ‡ na blogu ;). Ten klient dziaÅ‚aÅ‚ zdecydowanie lepiej:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">WebTarget</span> <span class="n">webTarget</span> <span class="o">=</span> <span class="n">createWebTarget</span><span class="o">();</span>
<span class="nc">Response</span> <span class="n">response</span> <span class="o">=</span> <span class="n">webTarget</span><span class="o">.</span><span class="na">queryParam</span><span class="o">(</span><span class="s">"statementNo"</span><span class="o">,</span> <span class="n">statementNumber</span><span class="o">).</span><span class="na">webTarget</span><span class="o">.</span><span class="na">request</span><span class="o">().</span><span class="na">get</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="jak-zaczÄ…Ä‡-z-wiresharkiem">Jak zaczÄ…Ä‡ z Wiresharkiem?</h2>
<p>Podobnych przykÅ‚adÃ³w mÃ³gÅ‚bym przywoÅ‚aÄ‡ wiÄ™cej, a kaÅ¼dy z nich utwierdza mnie w przekonaniu Å¼e warto nauczyÄ‡ siÄ™ korzystaÄ‡ z Wiresharka. Tym bardziej Å¼e jest to narzÄ™dzie niezaleÅ¼ne od zastosowanego stosu technologicznego, wiÄ™c jego znajomoÅ›Ä‡ moÅ¼e przydaÄ‡ siÄ™ w rÃ³Å¼nych projektach.</p>

<p>Instalacja na Ubuntu sprowadza siÄ™ do wykonania standardowych poleceÅ„:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt-add-repository universe
<span class="nb">sudo </span>apt-get update
<span class="nb">sudo </span>apt-get <span class="nb">install </span>wireshark
</code></pre></div></div>
<p>Dodatkowo Wireshark uÅ¼ywa biblioteki dumpcap, ktÃ³ra musi dostaÄ‡ uprawnienia do dziaÅ‚ania na uÅ¼ytkowniku root. Sprawdzamy jej lokalizacjÄ™:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>which dumpcap
</code></pre></div></div>
<p>a nastÄ™pnie:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo chmod </span>4711 <span class="o">[</span>lokalizacja]
</code></pre></div></div>

<p>Po uruchomieniu Wiresharka wybieramy opcjÄ™ â€œCapture/Optionsâ€, a nastÄ™pnie interfejs sieciowy, na ktÃ³rym chcemy nasÅ‚uchiwaÄ‡ - w wiÄ™kszoÅ›ci przypadkÃ³w najwygodniej jest wybraÄ‡ opcjÄ™ â€œanyâ€, czyli nasÅ‚uchiwaÄ‡ na wszystkich interfejsach sieciowych. NastÄ™pnie wpisujemy filtr przechwytywania okreÅ›lajÄ…cy jaki ruch sieciowy nas interesuje. CzÄ™sto wystarczy ograniczyÄ‡ przechwytywanie do okreÅ›lonego portu, na ktÃ³rym chcemy obejrzeÄ‡ Å¼Ä…dania:</p>

<p><img src="/assets/img/posts/2017-01-19-wireshark-czy-to-gryzie/1.png" alt="Opcje przechwytywania" /></p>

<p>Pozostaje juÅ¼ tylko uruchomiÄ‡ przechwytywanie i wykonaÄ‡ akcjÄ™ ktÃ³rÄ… chcemy przeanalizowaÄ‡. W oknie Wiresharka powinniÅ›my zobaczyÄ‡ zarejestrowany ruch sieciowy:</p>

<p><img src="/assets/img/posts/2017-01-19-wireshark-czy-to-gryzie/2.png" alt="Ruch sieciowy" /></p>

<p>AnalizujÄ…c komunikacjÄ™ HTTP najÅ‚atwiej jest wybraÄ‡ opcjÄ™ â€œFollow TCP Streamâ€, co pozwoli nam w przystÄ™pny sposÃ³b obejrzeÄ‡ nastÄ™pujÄ…ce po sobie Å¼Ä…dania i odpowiedzi na poziomie HTTP:</p>

<p><img src="/assets/img/posts/2017-01-19-wireshark-czy-to-gryzie/3.png" alt="StrumieÅ„ TCP" /></p>

<h2 id="koÅ„cowe-przemyÅ›lenia">KoÅ„cowe przemyÅ›lenia</h2>
<ul>
  <li>PowyÅ¼ej przedstawiÅ‚em oczywiÅ›cie tylko podstawowe moÅ¼liwoÅ›ci uÅ¼ycia narzÄ™dzia (aczkolwiek pokrywajÄ…ce 80% moich deweloperskich potrzeb). Oferuje ono dodatkowo wiele zaawansowanych ficzerÃ³w, jak choÄ‡by zaawansowane filtrowanie na poziomie przechwytywania i wyÅ›wietlania, kolorowanie pakietÃ³w, czy statystyki sieci.</li>
  <li>Wireshark nie zawsze moÅ¼e byÄ‡ wykorzystany bezpoÅ›rednio na danym hoÅ›cie, bo np. ten nie posiada graficznego interfejsu, co najczÄ™Å›ciej ma miejsce w Å›rodowisku serwerowym. WÃ³wczas moÅ¼na posiÅ‚kowaÄ‡ siÄ™ narzÄ™dziem tcpdump, ktÃ³rym moÅ¼emy zarejestrowaÄ‡ ruch sieciowy do pliku na docelowym Å›rodowisku, a nastÄ™pnie plik ten wczytaÄ‡ do analizy w programie Wireshark.</li>
  <li>Istnieje wiele innych narzÄ™dzi potrafiÄ…cych rejestrowaÄ‡ ruch HTTP, m.in. Fiddler czy Live HTTP Headers. Wydaje siÄ™ jednak Å¼e Wireshark jest bardziej wszechstronny i jego znajomoÅ›Ä‡ moÅ¼na wykorzystaÄ‡ rÃ³wnieÅ¼ w innych poza HTTP obszarach, np. dlaczego mÃ³j klient LDAP nie dziaÅ‚a, a inny tak?</li>
  <li>UÅ¼ywajÄ…c Wireshark/tcpdump moÅ¼emy analizowaÄ‡ ruch nie tylko na hoÅ›cie gdzie mamy uruchomione to narzÄ™dzie. Poprzez rÃ³Å¼ne techniki, takie jak port mirroring czy ARP poisoning, moÅ¼emy podsÅ‚uchiwaÄ‡ pakiety nie przechodzÄ…ce bezpoÅ›rednio przez naszego hosta.</li>
</ul>
:ET