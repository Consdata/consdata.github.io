I"q8<p>Każdy programista prędzej czy później ma do czynienia z jakąś formą API (ang. application programming interface). API to określony interfejs, którym dwie niezależne aplikacje mogą porozumiewać się między sobą. W tym artykule chciałbym przedstawić Wam nieco inne podejść do takiej komunikacji między aplikacjami.</p>

<h2 id="czym-są-webhooki">Czym są webhooki?</h2>
<p>Przyjmijmy, że napisaliśmy aplikację A. Chcielibyśmy także, aby wyświetlała ona pewne dane z aplikacji B - niech będzie to lista aktywnych użytkowników. W tym celu aplikacja B udostępnia nam API pozwalające na pobranie listy aktywnych użytkowników. W konwencjonalnym podejściu musielibyśmy odpytywać aplikację B o aktualną listę aktywnych użytkowników. Znacznie lepiej byłoby, gdyby to aplikacja B poinformowała naszą aplikację o zmianie na liście aktywnych użytkowników. W tym miejscu z pomocą przychodzą nam webhooki.</p>

<p>Webhook - jest to nieco inne podejście do komunikacji między aplikacjami. Mechanizm webhooków jest często nazywany Reverse API, ponieważ zwykle nie wymaga interakcji ze strony klienckiej (w naszym przykładzie aplikacji A). Prościej rzecz ujmując, webhooki pozwalają na powiadomienie aplikacji klienckiej o wystąpieniu pewnych zdarzeń.</p>

<p>Od strony implementacyjnej, webhooki są nieco prostsze, gdyż polegają de facto na wysłaniu request po zadanej strukturze, pod zadany adres, w wyniku wystąpienia jakiegoś zdarzenia. Integracja aplikacji klienckiej polega na wskazaniu adresu, na który ma zostać wysłany request.</p>

<p>Podsumowując, webhooki są bardzo przydatne w sytuacjach, gdy oczekujemy od aplikacji zewnętrznej informacji w wystąpieniu zdarzenia, gdyż pozwalają nam na uniknięcie aktywnego czekania po stronie naszej aplikacji.</p>

<p>Jeśli chodzi o wady webhooków, można wyróżnić dwie:</p>
<ul>
  <li>w momencie wystąpienia błędu w aplikacji możemy stracić zewnętrzne dane, gdyż nie mamy gwarancji, że zewnętrzna aplikacja w jakikolwiek sposób zareaguje na zgłoszony przez nas błąd - w przypadku klasycznego API moglibyśmy ponownie odpytać aplikację zewnętrzną,</li>
  <li>przy obsłudze webhooków musimy wziąć po uwagę, iż zdarzenia, o których jesteśmy powiadamiani, mogą występować bardzo często - zwykle nie mamy nad tym kontroli.</li>
</ul>

<h2 id="przykład-integracji">Przykład integracji</h2>
<p>We wcześniejszym wpisie (<a href="/2018/02/22/monitorowanie-zespolowych-trendow-jakosci-kodu.html">Monitorowanie zespołowych trendów jakości kodu</a>) przedstawiliśmy Wam nasz OpenSource’owy projekt – SonarQube Companion. Na jego przykładzie zaprezentuję, jak za pomocą webhooków można w łatwy sposób zintegrować kilka aplikacji.</p>

<p>Zintegrujemy SonarQube Compoaniona z komunikatorem Slack. Efektem integracji będzie wiadomość na kanale w komunikatorze z informacją, jak w ciągu ostatniego dnia zmieniła się liczba naruszeń zespołu.</p>

<h3 id="wymagania-wstępne">Wymagania wstępne:</h3>
<ul>
  <li>zapoznanie się z artykułem o SonarQube Companionie,</li>
  <li>skonfigurowany SonqrQube Companion,</li>
  <li>komunikator Slack.</li>
</ul>

<p>Na początek musimy skonfigurować webhooka po stronie komunikatora. Aby to zrobić, przechodzimy do ustawień integracji Slack’a. Dodajemy konfigurację aplikacji „Incoming WebHooks” i definiujemy, na jaki kanał chcemy wysyłać wiadomości:</p>

<p><img src="/assets/img/posts/2018-04-23-praktyczne-zastosowanie-webhook/1.png" alt="Konfiguracja komunikatora" /></p>

<p>Po pomyślnej konfiguracji, w widoku wybranego kanału, powinno ukazać nam się powiadomienie o pomyślnej konfiguracji:</p>

<p><img src="/assets/img/posts/2018-04-23-praktyczne-zastosowanie-webhook/2.png" alt="Komunikat komunikatora" /></p>

<p>Kolejnym krokiem będzie skonfigurowanie webhooka po stronie SonarQube Companiona.</p>

<p>W SonarQube Companionie mamy nieco bardziej rozbudowany model definiowania webhooków. Każda ze zdefiniowanych grup może zawierać swoją własną definicję webhooków. Definicja każdego webhooka składa się z trzech podstawowych elementów:</p>
<ul>
  <li><strong>action</strong> – akcje to określone zdarzenie / zachowanie, jakie ma zostać wykonane,</li>
  <li><strong>trigger</strong> – triggery definiują, kiedy akcja ma zostać wykonana,</li>
  <li><strong>callback</strong> – w jakiej formie aplikacja kliencka ma zostać poinformowana o wynikach akcji.
Pełna dokumentacja dostępnych akcji, triggerów i callbacków znajduje się na: <a href="https://github.com/Consdata/sonarqube-companion/wiki/Webhooks">https://github.com/Consdata/sonarqube-companion/wiki/Webhooks</a>.</li>
</ul>

<p>W ramach przykładu, zdefiniujemy webhooka, który sprawdzi, jak zmieniła się liczba naruszeń w obrębie grupy, w ciągu ostatniego dnia. W zależności od wyniku, wyślemy stosowny komunikat na kanał komunikatora.</p>

<p>Na początku definiujemy, w wyniku jakiej akcji mamy wysłać wiadomość. Aby to zrobić, w węźle webhooks definiujemy akcję dla nowego webhooka:</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">"webhooks"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w">
    </span><span class="nl">"action"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"NO_IMPROVEMENT"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"period"</span><span class="p">:</span><span class="w"> </span><span class="s2">"DAILY"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"severity"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"blockers"</span><span class="p">,</span><span class="w"> </span><span class="s2">"criticals"</span><span class="p">,</span><span class="w"> </span><span class="s2">"majors"</span><span class="p">]</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}]</span><span class="w">
</span></code></pre></div></div>
<p>Zdefiniowaliśmy w ten sposób akcję, która sprawdzi, czy w przeciągu ostantiego dnia poprawie uległa ilość naruszeń w obrępie projektów grupy. Dodatkowo, pod uwagę weźmie tylko naruszenia o priorytetach: blocker, critical oraz major.</p>

<p>Kolejnym krokiem będzie zdefiniowanie triggera akcji. W naszym przykładzie, dla ułatwienia, chcielibyśmy, aby akcja wykonywana była co minutę. Definiujemy trigger typu CRON:</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">"trigger"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"CRON"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"definition"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0 */1 * * * *"</span><span class="w">
</span><span class="p">}</span><span class="err">,</span><span class="w">
</span></code></pre></div></div>

<p>Na koniec definicja faktycznej integracji z komunikatorem. W tym celu definiujemy callback typu POST, w definicji którego podajemy URL pozyskany z panelu konfiguracyjnego Slack’a w polu “Webhook URL”:</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">"callbacks"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"POST"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"https://hooks.slack.com/services/*/*"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"body"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nl">"no_improvement"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{ 'text': 'http://gph.is/1RFg2r3 Brak poprawy'}"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"improvement"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{ 'text': 'http://gph.is/1a7RlDR Poprawiono ${diff}'"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"clean"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{ 'text': 'https://gph.is/1IH3RW6 Czysto'}"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>W sekcji body definiujemy treść wiadomości, jaka ma zostać wysłana w zależności od stanu grupy. Przykładowo, w przypadku, gdy stan naruszeń uległ poprawie (odpowiedź “improvement”), wyślemy gifa wraz z krótkim komentarzem zawierającym predefiniowaną zmienną akcji - ${diff}. W ten sposób, na kanale pojawi się informacja o liczbie poprawionych naruszeń w ciągu ostatniego dnia.</p>

<p>Całość konfiguracji przedstawia się następująco:</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">"webhooks"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"action"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"NO_IMPROVEMENT"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"period"</span><span class="p">:</span><span class="w"> </span><span class="s2">"DAILY"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"severity"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"blockers"</span><span class="p">,</span><span class="w"> </span><span class="s2">"criticals"</span><span class="p">,</span><span class="w"> </span><span class="s2">"majors"</span><span class="p">]</span><span class="w">
        </span><span class="p">},</span><span class="w">
        </span><span class="nl">"trigger"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"CRON"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"definition"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0 */1 * * * *"</span><span class="w">
        </span><span class="p">},</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"POST"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"https://hooks.slack.com/services/*/*"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"body"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nl">"no_improvement"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{ 'text': 'http://gph.is/1RFg2r3 Brak poprawy'}"</span><span class="p">,</span><span class="w">
                </span><span class="nl">"improvement"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{ 'text': 'http://gph.is/1a7RlDR Poprawiono ${diff}'"</span><span class="p">,</span><span class="w">
                </span><span class="nl">"clean"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{ 'text': 'https://gph.is/1IH3RW6 Czysto'}"</span><span class="w">
            </span><span class="p">}</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>
<p>W ten sposób, co minutę SonarQube Companion sprawdzi stan naruszeń grupy i w zależności od wyniku, wyśle określoną wiadomość na kanał komunikatora.</p>

<p>W rezultacie otrzymujemy wiadomość na kanale o braku poprawy jakichkolwiek naruszeń:
<img src="/assets/img/posts/2018-04-23-praktyczne-zastosowanie-webhook/3.png" alt="Wiadomość w komuniaktorze" /></p>

<p>Po poprawie jednego naruszenia, w kolejnej minucie otrzymujemy stosowne powiadomienie:
<img src="/assets/img/posts/2018-04-23-praktyczne-zastosowanie-webhook/4.png" alt="Wiadomość w komuniaktorze" /></p>

<p>W ten sposób zintegrowaliśmy dwie, niezależne aplikacje za pomocą mechanizmu webhooków, bez potrzeby pisania choćby linijki kodu.</p>

<h2 id="podsumowanie">Podsumowanie</h2>
<p>W artykule przedstawiłem koncepcję webhooków oraz pokazałem Wam, jak w prosty i szybki sposób można dzięki nim zintegrować dwie niezależne aplikacje. Zamierzamy stopniowo rozszerzać SonarQube Companiona o nowe akcje, np. przesyłanie cotygodniowego raportu o naruszeniach, poszczególnym użytkownikom - dlatego zalecam regularne odwiedzanie strony projektu :)</p>

<h2 id="przydatne-linki">Przydatne linki:</h2>
<ul>
  <li><a href="/2018/02/22/monitorowanie-zespolowych-trendow-jakosci-kodu.html">Monitorowanie zespołowych trendów jakości kodu</a></li>
  <li><a href="https://github.com/Consdata/sonarqube-companion">https://github.com/Consdata/sonarqube-companion</a></li>
  <li><a href="https://github.com/Consdata/sonarqube-companion/wiki/Webhooks">https://github.com/Consdata/sonarqube-companion/wiki/Webhooks</a></li>
</ul>
:ET