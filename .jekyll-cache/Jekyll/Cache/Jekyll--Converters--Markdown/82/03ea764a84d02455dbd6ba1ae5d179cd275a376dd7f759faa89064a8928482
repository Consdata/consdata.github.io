I"q<p>Od pewnego czasu pracujÄ™ nad Å›wieÅ¼ym projektem opartym o Angular 2. CzÄ™Å›ciÄ… projektu jest prezentowanie uÅ¼ytkownikowi dynamicznie generowanych elementÃ³w interfejsu. Nie jesteÅ›my w stanie zaprojektowaÄ‡ z wyprzedzeniem ekranÃ³w, nie znajÄ…c ani ich struktury, ani konkretnych kontrolek.</p>

<p>Standardowo aplikacjÄ™ budujemy korzystajÄ…c z komponentÃ³w uÅ¼ywajÄ…cych komponentÃ³w, ktÃ³re uÅ¼ywajÄ… komponentÃ³w, i tak dalejâ€¦ Komponenty okreÅ›lajÄ… selektory, ktÃ³rymi moÅ¼emy je osadzaÄ‡ oraz szablony HTML opisujÄ…ce sposÃ³b prezentacji. KorzystajÄ…c z tego zestawu, w kolejnych szablonach osadzamy kolejne komponenty wykorzystujÄ…c ich selektory, zupeÅ‚nie jakby byÅ‚y to natywne elementy HTMLa.</p>

<p>Co jednak, jeÅ¼eli nie jesteÅ›my w stanie ustaliÄ‡ konkretnego komponentu na etapie pisania aplikacji, a dopiero w trakcie jej wykonania? Musimy wymyÅ›liÄ‡ coÅ› kreatywnego :wink:</p>

<h2 id="szybkie-rozwiÄ…zanie">Szybkie rozwiÄ…zanie</h2>

<p>Pierwsze, co moÅ¼e nam przyjÅ›Ä‡ do gÅ‚owy, to wykorzystanie <em>ngIf</em> i opisanie widoku w formie frontendowego <em>switchâ€™a</em>.</p>

<p>SpÃ³jrzmy na przykÅ‚ad:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">({</span>
    <span class="na">selector</span><span class="p">:</span> <span class="dl">'</span><span class="s1">app</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">template</span><span class="p">:</span> <span class="s2">`</span><span class="err">
        &lt;div&gt;
            &lt;book-details  *ngIf="model.type === 'book'"&gt;&lt;/book-details&gt;
            &lt;movie-details *ngIf="model.type === 'movie'"&gt;&lt;/movie-details&gt;
            &lt;comic-details *ngIf="model.type === 'comic'"&gt;&lt;/comic-details&gt;
        &lt;/div&gt;
    </span><span class="s2">`</span>
<span class="p">})</span>
<span class="kd">class</span> <span class="nx">AppComponent</span> <span class="p">{}</span>
</code></pre></div></div>

<p>Na pierwszy rzut oka wszystko wyglÄ…da nieÅºle - w zaleÅ¼noÅ›ci od typu prezentowanego obiektu potrafimy wyÅ›wietliÄ‡ odpowiedni komponent prezentujÄ…cy szczegÃ³Å‚y. Nawet jesteÅ›my z siebie zadowoleni, w koÅ„cu mamy komponenty, a przecieÅ¼ mogliÅ›my zaszyÄ‡ prezentacjÄ™ typÃ³w bezpoÅ›rednio w szablonie :wink:</p>

<p>SpÃ³jrzmy jednak krytycznie na nasz twÃ³r, a zauwaÅ¼ymy potencjalne problemy.</p>

<p>Po pierwsze, dodanie nowego typu komponentu za kaÅ¼dym razem wiÄ…Å¼e siÄ™ z modyfikacjÄ… wszystkich szablonÃ³w komponentÃ³w zaleÅ¼nych. DodajÄ…c nowÄ… funkcjonalnoÅ›Ä‡ do systemu, bÄ™dziemy musieli zmieniÄ‡ wiele, teoretycznie niezaleÅ¼nych, fragmentÃ³w kodu. W praktyce, podÄ…Å¼ajÄ…c tÄ… drogÄ…, szybko dotrzemy do <em>wzorca Copyâ€™ego i Pasteâ€™a</em>. StÄ…d juÅ¼ blisko, Å¼eby trafiÄ‡ na projektowy <em>wall of shame</em> za klasyczny <a href="https://en.wikipedia.org/wiki/Shotgun_surgery"><em>Shotgun surgery</em></a>.</p>

<p>Kolejny, byÄ‡ moÅ¼e nawet bardziej narzucajÄ…cy siÄ™ problem, to wypÅ‚yniÄ™cie warstwy logiki do warstwy prezentacji. Mieszanie logiki z prezentacjÄ… to nigdy nie jest dobry pomysÅ‚. W szczegÃ³lnoÅ›ci w Å›wiecie frontendu, gdzie szukanie referencji czy refaktoryzacja pomiÄ™dzy HTMLem a JS/TSem to zawsze loteria.</p>

<h2 id="lepsze-podejÅ›cie">Lepsze podejÅ›cie</h2>

<p>A co gdybyÅ›my mogli przenieÅ›Ä‡ logikÄ™ wyboru komponentu do klasy? I dodatkowo wskazaÄ‡ w szablonie, gdzie komponent ma zostac wyrenderowany? Nadal nie tracÄ…c niczego z komponentowego podejÅ›cia, w tym wstrzykiwania zaleÅ¼noÅ›ci? DokÅ‚adnie tak moÅ¼emy to zrobiÄ‡ :wink:</p>

<h3 id="przygotowanie-szablonu-widoku">Przygotowanie szablonu widoku</h3>

<p>W pierwszym kroku przerobimy szablon komponentu:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">({</span>
    <span class="na">selector</span><span class="p">:</span> <span class="dl">'</span><span class="s1">app</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">template</span><span class="p">:</span> <span class="s2">`</span><span class="err">
        &lt;div&gt;
            &lt;div #details&gt;&lt;/div&gt;
        &lt;/div&gt;
    </span><span class="s2">`</span>
<span class="p">})</span>
<span class="kd">class</span> <span class="nx">AppComponent</span> <span class="p">{}</span>
</code></pre></div></div>

<p>Dotychczasowe definicje konkretnych komponentÃ³w zastÄ™pujemy pojedynczym <em>divâ€™em</em> peÅ‚niÄ…cym funkcjÄ™ placeholdera. Dodatowo oznaczamy go jako zmiennÄ… lokalnÄ… o nazwie <em>details</em>. DziÄ™ki temu w kolejnym kroku bÄ™dziemy mogli odnieÅ›Ä‡ siÄ™ do niego z kontrolera komponentu.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">(...)</span>
<span class="kd">class</span> <span class="nx">AppComponent</span> <span class="p">{</span>
    <span class="p">@</span><span class="nd">ViewChild</span><span class="p">(</span><span class="dl">'</span><span class="s1">details</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span><span class="na">read</span><span class="p">:</span> <span class="nx">ViewContainerRef</span><span class="p">})</span>
    <span class="k">private</span> <span class="nx">placeholder</span><span class="p">:</span> <span class="nx">ViewContainerRef</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>StosujÄ…c dekorator <em>@ViewChild</em> wstrzykujemy element <em>DOMu</em> do kontrolera komponentu. Pierwszy parametr moÅ¼e przyjÄ…Ä‡ klasÄ™ oczekiwanego elementu lub selektor. Dodatkowo przekazujemy, jakiej klasy element nas interesuje. W przypadku wstrzykiwania po selektorze standardowo jest to obiekt klasy <em>ElementRef</em>, nas jednak interesuje obiekt typu <em>ViewContainerRef</em>.</p>

<h3 id="tworzenie-komponentÃ³w-w-locie">Tworzenie komponentÃ³w w locie</h3>

<p>Klasa <em>ViewContainerRef</em> jest o tyle ciekawa, Å¼e dostarcza metodÄ™ pozwalajÄ…cÄ… tworzyÄ‡ komponenty w locie na podstawie dostarczonej fabryki:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">createComponent</span><span class="p">(</span>
	<span class="nx">componentFactory</span><span class="p">:</span> <span class="nx">ComponentFactory</span><span class="o">&lt;</span><span class="nx">C</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="nx">index</span><span class="p">?:</span> <span class="kr">number</span><span class="p">,</span>
    <span class="nx">injector</span><span class="p">?:</span> <span class="nx">Injector</span><span class="p">,</span>
    <span class="nx">projectableNodes</span><span class="p">?:</span> <span class="kr">any</span><span class="p">[][]</span>
<span class="p">)</span> <span class="p">:</span> <span class="nx">ComponentRef</span><span class="o">&lt;</span><span class="nx">C</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>Zmienna oznaczona dekoratorem <em>@ViewChild</em> zostanie uzupeÅ‚niona w trakcie tworzenia widoku - to znaczy, Å¼e moÅ¼emy siÄ™ niÄ… posÅ‚ugiwaÄ‡ dopiero w fazie <em>ngAfterViewInit</em>. W efekcie moÅ¼emy napisaÄ‡ kolejny kawaÅ‚ek naszego komponentu:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">(...)</span>
<span class="kd">class</span> <span class="nx">AppComponent</span> <span class="k">implements</span> <span class="nx">AfterViewInit</span> <span class="p">{</span>

    <span class="p">@</span><span class="nd">ViewChild</span><span class="p">(</span><span class="dl">'</span><span class="s1">details</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span><span class="na">read</span><span class="p">:</span> <span class="nx">ViewContainerRef</span><span class="p">})</span>
    <span class="k">private</span> <span class="nx">placeholder</span><span class="p">:</span> <span class="nx">ViewContainerRef</span><span class="p">;</span>

    <span class="k">private</span> <span class="nx">componentRef</span><span class="p">:</span> <span class="nx">ComponentRef</span><span class="o">&lt;</span><span class="kr">any</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="nx">ngAfterViewInit</span><span class="p">():</span><span class="k">void</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">componentRef</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">placeholder</span><span class="p">.</span><span class="nx">createComponent</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">componentFactory</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<h3 id="pobieranie-fabryki-komponentÃ³w">Pobieranie fabryki komponentÃ³w</h3>

<p>Teraz pozostaje nam juÅ¼ tylko uzyskanie fabryki komponentÃ³w. GotowÄ… do dziaÅ‚ania fabrykÄ™ najlepiej uzyskaÄ‡ z obiektu <em>ComponentFactoryResolver</em>. Sam komponent moÅ¼emy bez problemu wstrzyknÄ…Ä‡ z kontekstu <em>DI</em>, a nastÄ™pnie wywoÅ‚aÄ‡ na nim metodÄ™ <em>resolveComponentFactory</em>, podajÄ…c interesujÄ…cÄ… nas klasÄ™ komponentu.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">(...)</span>
<span class="kd">class</span> <span class="nx">AppComponent</span> <span class="k">implements</span> <span class="nx">OnInit</span> <span class="p">{</span>

    <span class="k">private</span> <span class="nx">componentFactory</span><span class="p">:</span> <span class="nx">ComponentFactory</span><span class="o">&lt;</span><span class="kr">any</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="k">private</span> <span class="nx">componentFactoryResolver</span><span class="p">:</span> <span class="nx">ComponentFactoryResolver</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="nx">ngOnInit</span><span class="p">():</span><span class="k">void</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">componentFactory</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">componentFactoryResolver</span><span class="p">.</span><span class="nx">resolveComponentFactory</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">componentClass</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>W ten sposÃ³b moÅ¼liwe jest stworzenie dowolnego komponentu osiÄ…galnego z kontekstu <em>DI</em> aplikacji.</p>

<h3 id="sprzÄ…tanie-po-komponencie">SprzÄ…tanie po komponencie</h3>

<p>Przy rÄ™cznym tworzeniu komponentÃ³w warto teÅ¼ pamiÄ™taÄ‡ o poprawnym zamkniÄ™ciu utworzonych obiektÃ³w. W tym celu moÅ¼emy wykorzystaÄ‡ fazÄ™ <em>ngOnDestroy</em> cyklu Å¼ycia komponentu.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">(...)</span>
<span class="kd">class</span> <span class="nx">AppComponent</span> <span class="k">implements</span> <span class="nx">OnDestroy</span> <span class="p">{</span>

    <span class="k">private</span> <span class="nx">componentRef</span><span class="p">:</span> <span class="nx">ComponentRef</span><span class="o">&lt;</span><span class="kr">any</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="nx">ngOnDestroy</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">componentRef</span><span class="p">.</span><span class="nx">destroy</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<h3 id="definiowanie-dynamicznych-komponentÃ³w-w-kontekÅ›cie-di">Definiowanie dynamicznych komponentÃ³w w kontekÅ›cie <em>DI</em></h3>

<p>Kolejna rzecz, o ktÃ³rej musimy pamiÄ™taÄ‡, to odpowiednie oznaczenie komponentÃ³w tworzonych dynamicznie na poziomie definicji kontekstu <em>DI</em>. Standardowo Angular generuje kod jedynie dla tych komponentÃ³w, dla ktÃ³rych zostaÅ‚y zdefiniowane referencje w kodzie. Takie referencje sÄ… tworzone automatycznie dla komponentÃ³w uÅ¼ytych w ramach metody bootstrap, w routingu, czy teÅ¼ po uÅ¼yciu w szablonach widokÃ³w. Wszystkie pozostaÅ‚e komponenty, nawet jeÅ¼eli zostaÅ‚y zdefiniowane w sekcji <em>declarations</em>, zostanÄ… pominiÄ™te - dziÄ™ki temu mechanizm <em>tree shaking</em> bÄ™dzie miaÅ‚ moÅ¼liwoÅ›Ä‡ pominÄ…Ä‡ je przy budowaniu produkcyjnej wersji kodu. Komponenty dodawane dynamicznie musimy sami wskazaÄ‡ jawnie, na poziomie definicji moduÅ‚u. W tym celu uÅ¼ywamy pola <em>entryComponents</em> dekoratora <em>@NgModule</em>.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">NgModule</span><span class="p">({</span>
    <span class="na">imports</span><span class="p">:</span> <span class="p">[...],</span>
    <span class="na">declarations</span><span class="p">:</span> <span class="p">[</span><span class="nx">BookDetails</span><span class="p">,</span> <span class="nx">MovieDetails</span><span class="p">,</span> <span class="nx">ComicDetails</span><span class="p">],</span>
    <span class="na">exports</span><span class="p">:</span> <span class="p">[...],</span>
    <span class="na">entryComponents</span><span class="p">:</span> <span class="p">[</span><span class="nx">BookDetails</span><span class="p">,</span> <span class="nx">MovieDetails</span><span class="p">,</span> <span class="nx">ComicDetails</span><span class="p">]</span>
<span class="p">})</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">ItemDetailsModule</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="przekazywanie-wartoÅ›ci-do-i-z-dynamicznego-komponentu">Przekazywanie wartoÅ›ci do i z dynamicznego komponentu</h3>

<p>OstatniÄ… rzeczÄ…, na ktÃ³rÄ… warto zwrÃ³ciÄ‡ uwagÄ™, jest przekazywanie wartoÅ›ci do i z komponentu. W przypadku rÄ™cznego dodawania komponentÃ³w do <em>DOM</em> nie moÅ¼emy skorzystaÄ‡ ze standardowego przekazywania wartoÅ›ci przez dekoratory <em>@Input()</em> i <em>@Output()</em>. KomunikacjÄ™ z komponentem musimy oprogramowaÄ‡ rÄ™cznie. Jednak nie jest to trudne, bo obiekt <em>ComponentRef</em> zawiera referencjÄ™ na faktycznÄ… instancjÄ™ stworzonego komponentu. WykorzystujÄ…c jÄ… moÅ¼emy zarÃ³wno ustawiÄ‡ wartoÅ›ci, jak i nasÅ‚uchiwaÄ‡ na zmiany.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">(...)</span>
<span class="kd">class</span> <span class="nx">AppComponent</span> <span class="k">implements</span> <span class="nx">AfterViewInit</span> <span class="p">{</span>

    <span class="k">private</span> <span class="nx">componentRef</span><span class="p">:</span> <span class="nx">ComponentRef</span><span class="o">&lt;</span><span class="kr">any</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="nx">ngAfterViewInit</span><span class="p">():</span><span class="k">void</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">componentRef</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">placeholder</span><span class="p">.</span><span class="nx">createComponent</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">componentFactory</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">componentRef</span><span class="p">.</span><span class="nx">instance</span><span class="p">.</span><span class="nx">inputVal</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hello world</span><span class="dl">'</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">componentRef</span><span class="p">.</span><span class="nx">instance</span><span class="p">.</span><span class="nx">outputVal</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">((...)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">});</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<h3 id="kompletny-przykÅ‚ad">Kompletny przykÅ‚ad</h3>

<p>Na koniec kompletny kod ÅºrÃ³dÅ‚owy omawianego przykÅ‚adu.</p>

<p><em>Komponent wrappera kontrolek</em></p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span>
    <span class="nx">Component</span><span class="p">,</span> <span class="nx">Input</span><span class="p">,</span> <span class="nx">OnInit</span><span class="p">,</span> <span class="nx">ViewContainerRef</span><span class="p">,</span> <span class="nx">ViewChild</span><span class="p">,</span> <span class="nx">ComponentFactoryResolver</span><span class="p">,</span> <span class="nx">Type</span><span class="p">,</span> <span class="nx">AfterViewInit</span><span class="p">,</span>
    <span class="nx">OnDestroy</span><span class="p">,</span> <span class="nx">ComponentRef</span>
<span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@angular/core</span><span class="dl">'</span><span class="p">;</span>

<span class="p">@</span><span class="nd">Component</span><span class="p">({</span>
    <span class="na">selector</span><span class="p">:</span> <span class="dl">'</span><span class="s1">control-wrapper</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">template</span><span class="p">:</span> <span class="s2">`</span><span class="err">
        &lt;div *ngIf="componentClass"&gt;
            &lt;div #componentHolder&gt;&lt;/div&gt;
        &lt;/div&gt;
    </span><span class="s2">`</span>
<span class="p">})</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">ControlWrapper</span> <span class="k">implements</span> <span class="nx">OnInit</span><span class="p">,</span> <span class="nx">AfterViewInit</span><span class="p">,</span> <span class="nx">OnDestroy</span> <span class="p">{</span>

    <span class="k">private</span> <span class="nx">model</span><span class="p">:</span> <span class="kr">any</span><span class="p">;</span>
    <span class="p">@</span><span class="nd">Input</span><span class="p">()</span>
    <span class="k">private</span> <span class="nx">controlFactory</span><span class="p">:</span> <span class="nx">IControlFactory</span><span class="p">;</span>
    <span class="p">@</span><span class="nd">ViewChild</span><span class="p">(</span><span class="dl">'</span><span class="s1">componentHolder</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span><span class="na">read</span><span class="p">:</span> <span class="nx">ViewContainerRef</span><span class="p">})</span>
    <span class="k">private</span> <span class="nx">componentHolder</span><span class="p">:</span> <span class="nx">ViewContainerRef</span><span class="p">;</span>
    <span class="k">private</span> <span class="nx">componentClass</span><span class="p">:</span> <span class="nx">Type</span><span class="o">&lt;</span><span class="nx">IControl</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">private</span> <span class="nx">componentRef</span><span class="p">:</span> <span class="nx">ComponentRef</span><span class="o">&lt;</span><span class="nx">IControl</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="k">private</span> <span class="nx">componentFactoryResolver</span><span class="p">:</span> <span class="nx">ComponentFactoryResolver</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="nx">ngOnInit</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">componentClass</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">controlFactory</span><span class="p">.</span><span class="nx">getControlClass</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="kd">type</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">ngOnDestroy</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">componentRef</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">componentRef</span><span class="p">.</span><span class="nx">destroy</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">ngAfterViewInit</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">componentClass</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">componentHolder</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">componentFactory</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">componentFactoryResolver</span><span class="p">.</span><span class="nx">resolveComponentFactory</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">componentClass</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">componentRef</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">componentHolder</span><span class="p">.</span><span class="nx">createComponent</span><span class="p">(</span><span class="nx">componentFactory</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">updateControlModel</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="nx">updateControlModel</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">componentRef</span><span class="p">.</span><span class="nx">instance</span><span class="p">.</span><span class="nx">setModel</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p><em>PrzykÅ‚adowa fabryka klas komponentÃ³w na podstawie modelu</em></p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nx">ItemDetailsControlFactory</span> <span class="k">implements</span> <span class="nx">IControlFactory</span> <span class="p">{</span>

    <span class="nx">getControlClass</span><span class="p">(</span><span class="kd">type</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">Type</span><span class="o">&lt;</span><span class="nx">IControlFactory</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">movie</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">BookDetails</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">book</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">MovieDetails</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">comic</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">ComicDetails</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p><em>Definicja moduÅ‚u dynamicznych komponentÃ³w</em></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span><span class="nx">NgModule</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@angular/core</span><span class="dl">'</span><span class="p">;</span>

<span class="p">@</span><span class="nd">NgModule</span><span class="p">({</span>
    <span class="na">imports</span><span class="p">:</span> <span class="p">[...],</span>
    <span class="na">declarations</span><span class="p">:</span> <span class="p">[</span><span class="nx">BookDetails</span><span class="p">,</span> <span class="nx">MovieDetails</span><span class="p">,</span> <span class="nx">ComicDetails</span><span class="p">],</span>
    <span class="na">exports</span><span class="p">:</span> <span class="p">[</span><span class="nx">BookDetails</span><span class="p">,</span> <span class="nx">MovieDetails</span><span class="p">,</span> <span class="nx">ComicDetails</span><span class="p">],</span>
    <span class="na">entryComponents</span><span class="p">:</span> <span class="p">[</span><span class="nx">BookDetails</span><span class="p">,</span> <span class="nx">MovieDetails</span><span class="p">,</span> <span class="nx">ComicDetails</span><span class="p">]</span>
<span class="p">})</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">ItemDetailsModule</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="tldr">tl;dr</h2>

<p>WykorzystujÄ…c najnowszÄ… wersjÄ™ frameworka Angular 2 moÅ¼emy bez problemu tworzyÄ‡ elementy interfejsu w locie, w trakcie dziaÅ‚ania aplikacji. Serwis <em>ComponentFactoryResolver</em> i adnotacja <em>@ViewChild</em> pozwalajÄ… programowo tworzyÄ‡ i dodawaÄ‡ komponenty do drzewa DOM, bez potrzeby zmieniania szablonÃ³w HTML komponentÃ³w.</p>

<h2 id="ÅºrÃ³dÅ‚a">Å¹rÃ³dÅ‚a</h2>

<ul>
  <li><a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#!#parent-to-child-local-var">Komunikacja pomiÄ™dzy komponentami, w tym oznaczanie jako zmienne lokalne i odwoÅ‚ania z kontrolerÃ³w.</a></li>
  <li><a href="https://angular.io/docs/ts/latest/api/core/index/ViewChild-decorator.html">Dokumentacja dekoratora <em>@ViewChild</em></a></li>
  <li><a href="https://angular.io/docs/ts/latest/api/core/index/ViewContainerRef-class.html">Dokumentacja klasy <em>ViewContainerRef</em></a></li>
  <li><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html">Cykl Å¼ycia komponentu</a></li>
  <li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#!#q-why-entry-components">FAQ na temat koniecznoÅ›ci uÅ¼ywania <em>entryComponents</em></a></li>
</ul>
:ET