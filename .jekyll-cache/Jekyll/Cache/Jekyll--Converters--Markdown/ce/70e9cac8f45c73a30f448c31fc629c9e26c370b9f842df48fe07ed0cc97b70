I"Á<p>W kaÅ¼dym projekcie pojawia siÄ™ moment, w ktÃ³rym pada stwierdzenie: â€œA co z wydajnoÅ›ciÄ…? Damy radÄ™ na produkcji?â€. I wtedy caÅ‚y zespÃ³Å‚ zastanawia siÄ™, ile tak naprawdÄ™ zniesie owoc ich wielomiesiÄ™cznych prac. Kod po wnikliwych review, poprawkach architektonicznych i projektowych wyglÄ…da wspaniale w repozytorium, ale analizujÄ…c go, trudno stwierdziÄ‡ czy aplikacja wytrzyma ruch na produkcji oraz gdzie sÄ… najsÅ‚absze ogniwa. Trzeba to sprawdziÄ‡ w praktyce. Przygotowujemy Å›rodowisko zasobami zbliÅ¼one do produkcji albo odpowiednio wyskalowane i klikamy. A co tam, zespÃ³Å‚ duÅ¼y, zaciÄ™cie klika i osiÄ…gamy ruch 5 uÅ¼ytkownikÃ³w. Szybka analiza logÃ³w i wszystko jest OK. Ale zaraz, to nic nam nie daje. Nadal nie zidentyfikowaliÅ›my najsÅ‚abszego ogniwa. Zautomatyzujmy zatem uÅ¼ytkownikÃ³w w systemie i wykonajmy symulacjÄ™ bardzo duÅ¼ej liczby uÅ¼ytkownikÃ³w. Pierwsze co przychodzi na myÅ›l, toâ€¦</p>

<p><img src="/assets/img/posts/2017-08-01-gatling/1.png" alt="JMeter" /></p>

<p>Nasz stary znajomy - Apache JMeter. Aplikacja bardzo rozbudowana, gdzie moÅ¼na tworzyÄ‡ skomplikowane przepÅ‚ywy uÅ¼ytkownikÃ³w. NarzÄ™dzie bogate w liczne funkcje, ale jak dla mnie doÅ›Ä‡ toporne. Pisanie w nim nowych scenariuszy zawsze idzie jakoÅ› ciÄ™Å¼ko. Praca jest lÅ¼ejsza, jeÅ›li moÅ¼na oprzeÄ‡ siÄ™ na starych testach. Trudno jednak czepraÄ‡ przyjemnoÅ›Ä‡ z pracy tym narzÄ™dziem.</p>

<p>RÃ³wnieÅ¼ w moim zespole, gdy pojawiÅ‚a siÄ™ kwestia testÃ³w wydajnoÅ›ciowych, pierwszÄ… sugestiÄ… byÅ‚o uÅ¼ycie JMeterâ€™a. GÅ‚Ã³wnie z racji dostÄ™pnych scenariuszy dla podobnego przepÅ‚ywu uÅ¼ytkownika. W trakcie dyskusji na temat wydajnoÅ›ci padÅ‚o, Å¼e w firmie, jeden z zespoÅ‚Ã³w uÅ¼yÅ‚ narzÄ™dzia Gatling, ktÃ³re sprawdziÅ‚o siÄ™ duÅ¼o lepiej, niÅ¼ narzÄ™dzie Apacha. PowÃ³d byÅ‚ bardzo prosty, scenariusze siÄ™ programuje, a nie klika w GUI. Przez co sÄ… czytelniejsze i Å‚atwiejsze do utrzymania w repo. Co prawda, w Gatlingu koduje siÄ™ w jÄ™zyku scala, ale nawet jeÅ›li, ktoÅ› nigdy nie programowaÅ‚ w tym jÄ™zyku, to bez problemu sobie poradzi. Podstawy w zupeÅ‚noÅ›ci wystarczÄ…. Nie jest potrzebna skomplikowana wiedza, o czym przekonujÄ… nawet twÃ³rcy na swojej stronie.</p>

<p>PoniÅ¼ej sprÃ³bujÄ™ przybliÅ¼yÄ‡ owe narzÄ™dzie posÅ‚ugujÄ…c siÄ™ prostym przykÅ‚adem.</p>

<h2 id="co-by-tu-potestowaÄ‡">Co by tu potestowaÄ‡?</h2>
<p>Na poczÄ…tku musimy przygotowaÄ‡ Å›rodowisko do testÃ³w. Wystawimy jakiÅ› prosty serwis z kilkoma metodami. Najszybciej bÄ™dzie skorzystaÄ‡ ze springbootâ€™a i zainicjowaÄ‡ projekt. Wchodzimy na <a href="https://start.spring.io">https://start.spring.io</a>, klikamy co nas interesuje i Å›ciÄ…gamy projekt. Importujemy i moÅ¼emy zaczynaÄ‡. Dodajemy prosty serwis.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">pl.consdata.server.controller</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>

<span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleWaitController</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">GENERIC_RESPONSE</span> <span class="o">=</span> <span class="s">"{\"result\": %1$d}"</span><span class="o">;</span>

  <span class="nd">@GetMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/getWaitTime"</span><span class="o">)</span>
  <span class="nd">@ResponseBody</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getWaitTime</span><span class="o">()</span> <span class="o">{</span>
     <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span>
     <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="no">GENERIC_RESPONSE</span><span class="o">,</span> <span class="mi">5000</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">5500</span><span class="o">));</span>
  <span class="o">}</span>

  <span class="nd">@PostMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/wait"</span><span class="o">)</span>
  <span class="nd">@ResponseBody</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">waitForNextStep</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">waitTime</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">waitTime</span><span class="o">);</span>
     <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
     <span class="o">}</span>
     <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="no">GENERIC_RESPONSE</span><span class="o">,</span> <span class="n">waitTime</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@GetMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/stop/{waitTime}"</span><span class="o">)</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">stop</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="nc">Integer</span> <span class="n">waitTime</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="s">"user end after: "</span> <span class="o">+</span> <span class="n">waitTime</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>FunkcjonalnoÅ›Ä‡ poszczegÃ³lnych metod nie jest skomplikowana, ale do testu wystarczy. ZakÅ‚adamy nastÄ™pujÄ…cy przepÅ‚yw uÅ¼ytkownika (kaÅ¼dy uÅ¼ytkownik postÄ™puje tak samo):</p>
<ul>
  <li>Pobiera czas przetwarzania</li>
  <li>WywoÅ‚uje przetwarzanie</li>
  <li>Czeka 5 sekund - po stronie uÅ¼ytkownika</li>
  <li>Opuszcza ten skomplikowany proces</li>
</ul>

<p>Skoro aplikacja jest gotowa, to sprÃ³bujmy zastanowiÄ‡ siÄ™: co jest sÅ‚abym ogniwem? Bystre oko zauwaÅ¼y, Å¼e endpoint â€˜/waitâ€™ moÅ¼e sprawiaÄ‡ problemy, gdyÅ¼ zawiera metodÄ™ â€˜sleepâ€™. OK, zgodzÄ™ siÄ™, ale pomimo tego - jaki ruch ta aplikacja wytrzyma i co pierwsze padnie? Tutaj odpowiedÅº juÅ¼ nie jest juÅ¼ taka oczywista. Przygotujmy zatem test wydajnoÅ›ciowy i sprawdÅºmy.</p>

<h2 id="zaprogramujmy-scenariusz-wydajnoÅ›ciowy">Zaprogramujmy scenariusz wydajnoÅ›ciowy</h2>
<p>PrzejdÅºmy zatem do naszego zadania, czyli napisania scenariusza pokrywajÄ…cego flow uÅ¼ytkownika. Zanim jednak do tego przystÄ…pimy, musimy pobraÄ‡ naszego frameworka. Skorzystamy z mojego ulubionego sposobu, czyli zaprzÄ™gniemy mavena, aby siÄ™ tym zajÄ…Å‚. W gÅ‚Ã³wnym pomâ€™ie dodajemy nastÄ™pujÄ…ce konfiguracje:</p>
<ul>
  <li>biblioteka wykorzystywana przez Gatlinga
    <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nt">&lt;dependencies&gt;</span>
     <span class="nt">&lt;dependency&gt;</span>
         <span class="nt">&lt;groupId&gt;</span>io.gatling.highcharts<span class="nt">&lt;/groupId&gt;</span>
         <span class="nt">&lt;artifactId&gt;</span>gatling-charts-highcharts<span class="nt">&lt;/artifactId&gt;</span>
         <span class="nt">&lt;version&gt;</span>2.2.4<span class="nt">&lt;/version&gt;</span>
         <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
     <span class="nt">&lt;/dependency&gt;</span>
  <span class="nt">&lt;/dependencies&gt;</span>
</code></pre></div>    </div>
  </li>
  <li>plugin odpowiedzialny za uruchamianie z poziomu mavena
    <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nt">&lt;plugin&gt;</span>
     <span class="nt">&lt;groupId&gt;</span>io.gatling<span class="nt">&lt;/groupId&gt;</span>
     <span class="nt">&lt;artifactId&gt;</span>gatling-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
     <span class="nt">&lt;version&gt;</span>2.2.4<span class="nt">&lt;/version&gt;</span>
     <span class="nt">&lt;configuration&gt;</span>
         <span class="nt">&lt;simulationsFolder&gt;</span>src/main<span class="nt">&lt;/simulationsFolder&gt;</span>
         <span class="nt">&lt;simulationClass&gt;</span>scala.simulation.SimpleWaitSimulation<span class="nt">&lt;/simulationClass&gt;</span>
     <span class="nt">&lt;/configuration&gt;</span>
     <span class="nt">&lt;executions&gt;</span>
         <span class="nt">&lt;execution&gt;</span>
             <span class="nt">&lt;goals&gt;</span>
                 <span class="nt">&lt;goal&gt;</span>execute<span class="nt">&lt;/goal&gt;</span>
             <span class="nt">&lt;/goals&gt;</span>
         <span class="nt">&lt;/execution&gt;</span>
     <span class="nt">&lt;/executions&gt;</span>
  <span class="nt">&lt;/plugin&gt;</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Dodatkowo, w konfiguracji dodajemy Å›cieÅ¼kÄ™ ze ÅºrÃ³dÅ‚ami oraz domyÅ›lnÄ… klasÄ™ naszej symulacji. Klasa ta musi dziedziczyÄ‡ po obiekcie â€˜Simulationâ€™ z pakietu Gatlinga. Po stworzeniu klasy â€˜SimpleWaitSimulationâ€™, uruchamiamy symulacjÄ™ w konsoli poleceniem:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mvn gatling:execute
</code></pre></div></div>

<p>PowinniÅ›my dostaÄ‡ bÅ‚Ä…d:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Caused by: java.lang.IllegalArgumentException: requirement failed: No scenario set up
</code></pre></div></div>

<p>BÅ‚Ä…d ten informuje nas, Å¼e nasza symulacja nie zawiera scenariusza, co oczywiÅ›cie jest prawdÄ… na tym etapie, ale potwierdza nam dziaÅ‚anie szkieletu symulacji. MoÅ¼emy zatem przejÅ›Ä‡ dalej i skupiÄ‡ siÄ™ na zakodowaniu naszego testu. Uruchamiamy wczeÅ›niej napisanÄ… aplikacjÄ™ do testowania i ruszamy.</p>

<p>W pierwszej kolejnoÅ›ci definiujemy podstawy komunikacji naszego testu z serwerem.</p>

<p>Aplikacja uruchamia siÄ™ na standardowym adresie i porcie, zatem takie wartoÅ›ci przekazujemy. W Gatlingu za konfiguracjÄ™ komunikacji odpowiada klasa â€˜httpâ€™. Ustawiamy adres bazowy, pod ktÃ³rym szukaÄ‡ naleÅ¼y naszej aplikacji. Nasz test bÄ™dzie symulowaÅ‚ uderzenia z przeglÄ…darki, zatem ustawiamy odpowiednie nagÅ‚Ã³wki wykorzystywane przy requestach. Powstaje nastÄ™pujÄ…cy kod:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">httpConf</span> <span class="k">=</span> <span class="n">http</span>
    <span class="o">.</span><span class="py">baseURL</span><span class="o">(</span><span class="s">"http://localhost:8080"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">acceptHeader</span><span class="o">(</span><span class="s">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">acceptEncodingHeader</span><span class="o">(</span><span class="s">"gzip, deflate"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">acceptLanguageHeader</span><span class="o">(</span><span class="s">"en-US,en;q=0.5"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">userAgentHeader</span><span class="o">(</span><span class="s">"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:50.0) Gecko/20100101 Firefox/50.0"</span><span class="o">)</span>
</code></pre></div></div>
<p>Teraz moÅ¼emy zaprogramowaÄ‡ scenariusz, czyli krok po kroku wykonaÄ‡ to, co wykonuje symulowany uÅ¼ytkownik. Za tworzenie scenariusza odpowiada polecenie â€˜scenarioâ€™. Na poczÄ…tku powoÅ‚ajmy instancjÄ™ tego obiektu.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">scn</span> <span class="k">=</span> <span class="nf">scenario</span><span class="o">(</span><span class="s">"Simple Wait simulation"</span><span class="o">)</span>
</code></pre></div></div>

<p>W tym momencie mamy zalÄ…Å¼ek scenariusza i moÅ¼emy zaczÄ…Ä‡ dodawaÄ‡ poszczegÃ³lne wywoÅ‚ania. W pierwszym kroku uÅ¼ytkownik wywoÅ‚uje metodÄ… GET endpointa â€˜/getWaitTimeâ€™, a w odpowiedzi otrzymuje dane, ktÃ³re musi zapamiÄ™taÄ‡ i wykorzystaÄ‡ w kolejnym etapie. Praca z Gatlingiem jest bardzo wygodna. Dostajemy masÄ™ uÅ¼ytecznych poleceÅ„, dziÄ™ki ktÃ³rym moÅ¼emy wykonywaÄ‡ rÃ³Å¼ne operacje. ZarÃ³wno na wejÅ›ciowych, jak i wyjÅ›ciowych danych z testu. Na poczÄ…tku dodajemy wywoÅ‚anie GET:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="py">exec</span><span class="o">(</span><span class="nf">http</span><span class="o">(</span><span class="s">"Take waiting time"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"/getWaitTime"</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div></div>
<p>CaÅ‚kiem proste. PowyÅ¼szy kod wywoÅ‚a tylko wskazanego endpointa. Brakuje nam pobrania odpowiedzi i zapamiÄ™tania wartoÅ›ci. Dodatkowo powinniÅ›my dostaÄ‡ kod statusu http rÃ³wny 200. W naszym przypadku oznacza to, Å¼e wywoÅ‚anie powiodÅ‚o siÄ™, a serwer wyÅ›le do nas jsona z polem o nazwie â€˜resultâ€™. WartoÅ›Ä‡ tÄ™ musimy zapamiÄ™taÄ‡ i wykorzystaÄ‡ do dalszego procesowania uÅ¼ytkownika. UzupeÅ‚nijmy nasze proste wywoÅ‚anie o niezbÄ™dne elementy:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">scn</span> <span class="k">=</span> <span class="nf">scenario</span><span class="o">(</span><span class="s">"Simple Wait simulation"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">exec</span><span class="o">(</span><span class="nf">http</span><span class="o">(</span><span class="s">"Take waiting time"</span><span class="o">)</span>
        <span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"/getWaitTime"</span><span class="o">)</span>
        <span class="o">.</span><span class="py">check</span><span class="o">(</span><span class="nv">status</span><span class="o">.</span><span class="py">is</span><span class="o">(</span><span class="mi">200</span><span class="o">))</span>
        <span class="o">.</span><span class="py">check</span><span class="o">(</span><span class="nf">jsonPath</span><span class="o">(</span><span class="s">"$.result"</span><span class="o">).</span><span class="py">saveAs</span><span class="o">(</span><span class="s">"waitTime"</span><span class="o">))</span>
    <span class="o">)</span>
</code></pre></div></div>
<p>Podobnie jak wczeÅ›niej skorzystaliÅ›my z wbudowanych narzÄ™dzi Gatlinga. â€˜Checkâ€™ operuje na odpowiedzi wszystkich requestÃ³w. MetodÄ… â€˜statusâ€™ sprawdzamy kod odpowiedzi, czyli oczekujemy wartoÅ›ci 200. Metodami â€˜jsonPathâ€™ wyciÄ…gamy niezbÄ™dne informacje z odpowiedzi, a poleceniem â€˜saveAsâ€™ zapamiÄ™tamy te dane. Warto wspomnieÄ‡, iÅ¼ Gatling do kaÅ¼dego uÅ¼ytkownika tworzy sesjÄ™ uÅ¼ytkownika, do ktÃ³rej moÅ¼emy zarÃ³wno zapisywaÄ‡, jak i odczytywaÄ‡ wartoÅ›ci. Istnieje takÅ¼e moÅ¼liwoÅ›Ä‡ odczytywania wielu wartoÅ›ci w ramach jednego Å¼Ä…dania, wÃ³wczas musimy tylko skopiowaÄ‡ polecenie â€˜checkâ€™ i odpowiednio ustawiÄ‡, co i jak chcemy zapisaÄ‡.</p>

<p>IdÄ…c dalej, uÅ¼ytkownik wywoÅ‚uje endpoint â€˜/waitâ€™ przekazujÄ…c wartoÅ›Ä‡ z pierwszego Å¼Ä…dania, a otrzymujÄ…c innÄ… wartoÅ›Ä‡, ktÃ³rÄ… takÅ¼e zapamiÄ™tujemy. PostÄ™pujÄ…c zgodnie z opisem, kodujemy:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="py">exec</span><span class="o">(</span><span class="nf">http</span><span class="o">(</span><span class="s">"Wait for"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">post</span><span class="o">(</span><span class="s">"/wait"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">formParam</span><span class="o">(</span><span class="s">"""waitTime"""</span><span class="o">,</span> <span class="s">"${waitTime}"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">check</span><span class="o">(</span><span class="nv">status</span><span class="o">.</span><span class="py">is</span><span class="o">(</span><span class="mi">200</span><span class="o">))</span>
    <span class="o">.</span><span class="py">check</span><span class="o">(</span><span class="nf">jsonPath</span><span class="o">(</span><span class="s">"$.result"</span><span class="o">).</span><span class="py">saveAs</span><span class="o">(</span><span class="s">"realWaitTime"</span><span class="o">))</span>
    <span class="o">)</span>
</code></pre></div></div>
<p>Nowym elementem, jaki tutaj wykorzystaliÅ›my, jest polecenie â€˜formParamâ€™. Jak nazwa sugeruje, sÅ‚uÅ¼y ono do przekazywania parametrÃ³w do wywoÅ‚ania. Poza nazwÄ…, w formularzu podajemy wartoÅ›Ä‡: bezpoÅ›rednio lub za pomocÄ… zmiennej. W tym przypadku odczytaliÅ›my z sesji wczeÅ›niej zapisanÄ… wartoÅ›Ä‡.</p>

<p>W kolejnym etapie uÅ¼ytkownik czeka kilka sekund, zanim wywoÅ‚a nastÄ™pnÄ… operacjÄ™. Aby to osiÄ…gnÄ…Ä‡, w prosty sposÃ³b moÅ¼emy wykorzystaÄ‡ wbudowanÄ… metodÄ™ â€˜pauseâ€™. Jako parametr przyjmujemy wartoÅ›Ä‡, oznaczajÄ…cÄ… iloÅ›Ä‡ czasu, ktÃ³rÄ… symulowany uÅ¼ytkownik ma czekaÄ‡ przed wykonaniem nastÄ™pnego kroku. Polecenie proste, ale uÅ¼yteczne. MoÅ¼emy w ten sposÃ³b symulowaÄ‡ np. wypeÅ‚nianie formularza czy klikanie w jakiÅ› przycisk.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="py">pause</span><span class="o">(</span><span class="mi">5</span> <span class="n">seconds</span><span class="o">)</span>
</code></pre></div></div>
<p>W ostatnim kroku uÅ¼ytkownik wywoÅ‚uje tak, jak na poczÄ…tku polecenie GET, ale tym razem przekazujÄ…c wartoÅ›Ä‡. W odpowiedzi nie otrzymuje JSONa, ale prosty ciÄ…g znakÃ³w. Rezultat odpowiedzi sprawdzimy czy zawiera interesujÄ…cÄ… nas wartoÅ›Ä‡ przekazanÄ… w Å¼Ä…daniu.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="py">exec</span><span class="o">(</span><span class="nf">http</span><span class="o">(</span><span class="s">"User stop"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"/stop/${realWaitTime}"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">check</span><span class="o">(</span><span class="nv">status</span><span class="o">.</span><span class="py">is</span><span class="o">(</span><span class="mi">200</span><span class="o">),</span> <span class="nv">bodyBytes</span><span class="o">.</span><span class="py">saveAs</span><span class="o">(</span><span class="s">"endMessageBody"</span><span class="o">))</span>
    <span class="o">.</span><span class="py">check</span><span class="o">(</span><span class="nf">substring</span><span class="o">(</span><span class="s">"${realWaitTime}"</span><span class="o">).</span><span class="py">exists</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div></div>
<p>Poza wykorzystywanymi poprzednio poleceniami, uÅ¼yliÅ›my tutaj kolejnej metody Gatlinga, tym razem do operacji na stringach. â€˜Substringâ€™ pozwala w prosty sposÃ³b operowaÄ‡ na ciÄ…gach znakÃ³,w np. znajdujÄ…c podanÄ… na wejÅ›ciu frazÄ™. Serwer powinien wysÅ‚aÄ‡ nam â€œstringaâ€ zawierajÄ…cego przekazany na wejÅ›ciu parametr. Dlatego teÅ¼ weryfikujemy, czy otrzymana odpowiedÅº zawiera Ã³w wartoÅ›Ä‡.</p>

<p>CaÅ‚y przepÅ‚yw uÅ¼ytkownika mamy juÅ¼ zakodowany. Na koÅ„cu, zbierzmy wszystkie kroki w jednym miejscu. KaÅ¼de polecenie do wykonania operacji uÅ¼ytkownika zwraca instancjÄ™ scenariusza, zatem w prosty sposÃ³b moÅ¼emy agregowaÄ‡ polecenia. W efekcie nasz wynikowy scenariusz wyglÄ…da nastÄ™pujÄ…co:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">scn</span> <span class="k">=</span> <span class="nf">scenario</span><span class="o">(</span><span class="s">"Simple Wait simulation"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">exec</span><span class="o">(</span><span class="nf">http</span><span class="o">(</span><span class="s">"Take waiting time"</span><span class="o">)</span>
        <span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"/getWaitTime"</span><span class="o">)</span>
        <span class="o">.</span><span class="py">check</span><span class="o">(</span><span class="nv">status</span><span class="o">.</span><span class="py">is</span><span class="o">(</span><span class="mi">200</span><span class="o">))</span>
        <span class="o">.</span><span class="py">check</span><span class="o">(</span><span class="nf">jsonPath</span><span class="o">(</span><span class="s">"$.result"</span><span class="o">).</span><span class="py">saveAs</span><span class="o">(</span><span class="s">"waitTime"</span><span class="o">))</span>
    <span class="o">)</span>
    <span class="o">.</span><span class="py">exec</span><span class="o">(</span><span class="nf">http</span><span class="o">(</span><span class="s">"Wait for"</span><span class="o">)</span>
        <span class="o">.</span><span class="py">post</span><span class="o">(</span><span class="s">"/wait"</span><span class="o">)</span>
        <span class="o">.</span><span class="py">formParam</span><span class="o">(</span><span class="s">"""waitTime"""</span><span class="o">,</span> <span class="s">"${waitTime}"</span><span class="o">)</span>
        <span class="o">.</span><span class="py">check</span><span class="o">(</span><span class="nv">status</span><span class="o">.</span><span class="py">is</span><span class="o">(</span><span class="mi">200</span><span class="o">))</span>
        <span class="o">.</span><span class="py">check</span><span class="o">(</span><span class="nf">jsonPath</span><span class="o">(</span><span class="s">"$.result"</span><span class="o">).</span><span class="py">saveAs</span><span class="o">(</span><span class="s">"realWaitTime"</span><span class="o">)))</span>
        <span class="o">.</span><span class="py">pause</span><span class="o">(</span><span class="mi">5</span> <span class="n">seconds</span><span class="o">)</span>
    <span class="o">)</span>
    <span class="o">.</span><span class="py">exec</span><span class="o">(</span><span class="nf">http</span><span class="o">(</span><span class="s">"User stop"</span><span class="o">)</span>
        <span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"/stop/${realWaitTime}"</span><span class="o">)</span>
        <span class="o">.</span><span class="py">check</span><span class="o">(</span><span class="nv">status</span><span class="o">.</span><span class="py">is</span><span class="o">(</span><span class="mi">200</span><span class="o">),</span> <span class="nv">bodyBytes</span><span class="o">.</span><span class="py">saveAs</span><span class="o">(</span><span class="s">"endMessageBody"</span><span class="o">))</span>
        <span class="o">.</span><span class="py">check</span><span class="o">(</span><span class="nf">substring</span><span class="o">(</span><span class="s">"${realWaitTime}"</span><span class="o">).</span><span class="py">exists</span><span class="o">)</span>
    <span class="o">)</span>
</code></pre></div></div>
<p>W nastÄ™pnym kroku zajmiemy siÄ™ konfiguracjÄ… i przygotowaniem ruchu uÅ¼ytkownikÃ³w.</p>

<h2 id="pierwsze-strzaÅ‚y">Pierwsze strzaÅ‚y</h2>
<p>Mamy gotowy scenariusz, aby jednak nasza symulacja zostaÅ‚a poprawnie uruchomiona, trzeba jÄ… jeszcze skonfigurowaÄ‡. W tym celu musimy wywoÅ‚aÄ‡ metodÄ™ â€˜setUp()â€™, ktÃ³ra poÅ‚Ä…czy nam wszystkie elementy tzn.: komunikacjÄ™, scenariusz i ruch uÅ¼ytkownikÃ³w. Nie jest to skomplikowana operacja. W jej efekcie powstanie jedna linijka kodu:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">setUp</span><span class="o">(</span><span class="nv">scn</span><span class="o">.</span><span class="py">inject</span><span class="o">(</span><span class="nf">atOnceUsers</span><span class="o">(</span><span class="mi">1</span><span class="o">)).</span><span class="py">protocols</span><span class="o">(</span><span class="n">httpConf</span><span class="o">))</span>
</code></pre></div></div>
<p>Na poczÄ…tek, w celu sprawdzenia czy wszystko poprawnie dziaÅ‚a, uruchomimy test tylko z jednym uÅ¼ytkownikiem. UÅ¼yjemy tutaj polecenia â€˜atOnceUsers(1)â€™, ktÃ³re symuluje wÅ‚aÅ›nie okreÅ›lonÄ… liczbÄ™ uÅ¼ytkownikÃ³w na start testu. Wszystko gotowe, zatem moÅ¼emy uruchamiaÄ‡. Odpalamy konsolÄ™ i uruchamiamy polecenie:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mvn gatling:execute
</code></pre></div></div>
<p>JeÅ›li wszystko poszÅ‚o OK, to dostajemy:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[INFO] BUILD SUCCESS
</code></pre></div></div>
<p>PrzeglÄ…damy logi i weryfikujemy czy otrzymaliÅ›my nastÄ™pujÄ…ce wyniki:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--- Requests ------------------------------------------------------------------
Global (OK=3 KO=0 )
Take waiting time (OK=1 KO=0 )
Wait for (OK=1 KO=0 )
User stop (OK=1 KO=0 )
</code></pre></div></div>

<p>JeÅ›li mamy takie wypiski, to wszystko jest w jak najlepszym porzÄ…dku.</p>

<p>Przy takiej konfiguracji testu mamy w sumie 3 uderzenia do aplikacji, zatem ciÄ™Å¼ko wnioskowaÄ‡ i mÃ³wiÄ‡ tu o jakichÅ› wynikach do analizy. Testowo moÅ¼emy spojrzeÄ‡ sobie na raport, ktÃ³ry wygenerowany zostaÅ‚ automatycznie na koniec testu. Wystarczy poszukaÄ‡ â€˜Please open the following file:â€™ gdzie znajduje siÄ™ strona html z wszystkimi wynikami naszego testu. DokÅ‚adniej przyjrzymy siÄ™ temu, gdy uderzeÅ„ bÄ™dzie o wiele wiÄ™cej. Ustalmy zatem wiÄ™kszy ruch.</p>

<h2 id="och-ilu-tych-uÅ¼ytkownikÃ³w">â€œOch, ilu tych uÅ¼ytkownikÃ³wâ€</h2>
<p>Ruch jednego uÅ¼ytkownika nie jest w stanie zbadaÄ‡ nam wydajnoÅ›ci aplikacji. Dlatego musimy zastanowiÄ‡ siÄ™, jaki ruch chcemy wygenerowaÄ‡. OczywiÅ›cie, jeÅ›li mowa o prawdziwych aplikacjac,h to musimy wziÄ…Ä‡ pod uwagÄ™ charakterystykÄ™ dziaÅ‚ania naszej aplikacji w Å›rodowisku produkcyjnym. Czy jest to ruch liniowy, skokowy, impulsowy itp. I to wÅ‚aÅ›nie rozkÅ‚ad ruchu na produkcji powinien determinowaÄ‡, w jaki sposÃ³b generujemy ruch uÅ¼ytkownikÃ³w w systemie w trakcie testu.</p>

<p>Gatling ma kilka sposobÃ³w generowania ruchu. PoniewaÅ¼ metod jest wiele, warto spojrzeÄ‡ do dokumentacji - <a href="http://gatling.io/docs/current/general/simulation_setup/">http://gatling.io/docs/current/general/simulation_setup/</a>. My zakÅ‚adamy, Å¼e w kaÅ¼dej sekundzie do systemu bÄ™dzie wpadaÄ‡ okreÅ›lona liczba nowych uÅ¼ytkownikÃ³w, postÄ™pujÄ…cych wedÅ‚ug poprzednio opisanego scenariusza. Przy konfiguracji symulacji wykorzystamy dwie metody:</p>
<ul>
  <li>â€™nothingFor()â€™ - do rozÅ‚adowania poprzedniego ruchu</li>
  <li>â€˜constantUsersPerSec() during() randomizedâ€™ - do symulowania okreÅ›lonej liczby uÅ¼ytkownikÃ³w przez ustalony czas.</li>
</ul>

<p>W poczÄ…tkowej fazie naleÅ¼y wykonaÄ‡ wstÄ™pne testy i okreÅ›liÄ‡ wartoÅ›ci w jakich bÄ™dziemy siÄ™ poruszaÄ‡. Nie ma sensu przeprowadzaÄ‡ godzinnego testu, jeÅ›li aplikacja â€œwywali siÄ™â€ w ciÄ…gu pierwszych sekund. Po wykonaniu takich szybkich testÃ³w, moÅ¼emy przystÄ…piÄ‡ do finalnej konfiguracji.</p>

<p>Dobrym rozwiÄ…zaniem jest przeprowadzanie testÃ³w w ramach kilku iteracji. KaÅ¼da z nich skÅ‚ada siÄ™ z fazy obciÄ…Å¼enia aplikacji uÅ¼ytkownikami, a nastÄ™pnie czasu potrzebnego na zakoÅ„czenie przetwarzania wszystkich uÅ¼ytkownikÃ³w. WÃ³wczas moÅ¼emy uruchomiÄ‡ nastÄ™pne powtÃ³rzenie, ale zwiÄ™kszajÄ…c liczbÄ™ uÅ¼ytkownikÃ³w. O tym jak przeprowadzaÄ‡ testy wydajnoÅ›ciowe, moÅ¼na by napisaÄ‡ nastÄ™pny artykuÅ‚ czy nawet ksiÄ…Å¼kÄ™.</p>

<p>WrÃ³Ä‡my zatem do naszej symulacji. Wykonamy piÄ™Ä‡ iteracji, kaÅ¼da bÄ™dzie siÄ™ skÅ‚adaÄ‡ z obciÄ…Å¼enia uÅ¼ytkownikami trwajÄ…cym 100 sekund, nastÄ™pnie przez 60 sekund bÄ™dziemy czekaÄ‡ zanim uruchomimy nastÄ™pne powtÃ³rzenie. Zaczniemy od 20 nowych uÅ¼ytkownikÃ³w na sekundÄ™ i bÄ™dziemy zwiÄ™kszaÄ‡ ich liczbÄ™ o kolejnych 10 w nastÄ™pnych iteracjach. Podobnie jak w przypadku scenariusza, moÅ¼emy agregowaÄ‡ poszczegÃ³lne fazy testu. Dla powyÅ¼szych zaÅ‚oÅ¼eÅ„ mamy nastÄ™pujÄ…cÄ… konfiguracjÄ™:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">setUp</span><span class="o">(</span><span class="nv">scn</span><span class="o">.</span><span class="py">inject</span><span class="o">(</span><span class="nf">constantUsersPerSec</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span> <span class="nf">during</span><span class="o">(</span><span class="mi">100</span> <span class="n">seconds</span><span class="o">)</span> <span class="n">randomized</span><span class="o">,</span>
<span class="nf">nothingFor</span><span class="o">(</span><span class="mi">60</span> <span class="n">seconds</span><span class="o">),</span>
<span class="nf">constantUsersPerSec</span><span class="o">(</span><span class="mi">30</span><span class="o">)</span> <span class="nf">during</span><span class="o">(</span><span class="mi">100</span> <span class="n">seconds</span><span class="o">)</span> <span class="n">randomized</span><span class="o">,</span>
<span class="nf">nothingFor</span><span class="o">(</span><span class="mi">60</span> <span class="n">seconds</span><span class="o">),</span>
<span class="nf">constantUsersPerSec</span><span class="o">(</span><span class="mi">40</span><span class="o">)</span> <span class="nf">during</span><span class="o">(</span><span class="mi">100</span> <span class="n">seconds</span><span class="o">)</span> <span class="n">randomized</span><span class="o">,</span>
<span class="nf">nothingFor</span><span class="o">(</span><span class="mi">60</span> <span class="n">seconds</span><span class="o">),</span>
<span class="nf">constantUsersPerSec</span><span class="o">(</span><span class="mi">50</span><span class="o">)</span> <span class="nf">during</span><span class="o">(</span><span class="mi">100</span> <span class="n">seconds</span><span class="o">)</span> <span class="n">randomized</span><span class="o">,</span>
<span class="nf">nothingFor</span><span class="o">(</span><span class="mi">60</span> <span class="n">seconds</span><span class="o">),</span>
<span class="nf">constantUsersPerSec</span><span class="o">(</span><span class="mi">60</span><span class="o">)</span> <span class="nf">during</span><span class="o">(</span><span class="mi">100</span> <span class="n">seconds</span><span class="o">)</span> <span class="n">randomized</span>
<span class="o">).</span><span class="py">protocols</span><span class="o">(</span><span class="n">httpConf</span><span class="o">))</span>
</code></pre></div></div>

<p>Konfiguracja gotowa, czas na uruchomienie.</p>

<h2 id="wielkie-strzelanie">Wielkie strzelanie</h2>
<p>W koÅ„cu dotarliÅ›my do momentu, w ktÃ³rym moÅ¼emy sprawdziÄ‡, jak zachowuje siÄ™ nasza aplikacja przy duÅ¼ym obciÄ…Å¼eniu. Wszystko gotowe, uruchamiamy symulacjÄ™ i idziemy na kawÄ™. Jak juÅ¼ wypijemy, jest szansa, Å¼e nasz test siÄ™ zakoÅ„czyÅ‚. WÃ³wczas w logach, tak jak poprzednio, otrzymamy:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[INFO] BUILD SUCCESS
</code></pre></div></div>
<p>NastÄ™pnie szukamy, gdzie wygenerowany zostaÅ‚ raport: â€˜Please open the following file:â€™. Odpalamy i naszym oczom pojawia siÄ™ automatycznie wygenerowany raport.</p>

<p>Przejrzyjmy otrzymane wyniki. Pierwsze bÅ‚Ä™dy zaczÄ™Å‚y siÄ™ pojawiaÄ‡ przy ruchu 50 nowych uÅ¼ytkownikÃ³w na sekundÄ™. CaÅ‚kiem nieÅºle. WidaÄ‡ jednak, Å¼e aplikacja przetwarzaÅ‚a caÅ‚y ruch tylko przy 20 nowych uÅ¼ytkownikach na sekundÄ™. JuÅ¼ przy kolejnej iteracji widaÄ‡ tendencjÄ™ wzrostowÄ… aktywnych uÅ¼ytkownikÃ³w. Oznacza to, Å¼e aplikacja nie radziÅ‚a sobie z caÅ‚ym ruchem, jaki byÅ‚ generowany i czÄ™Å›Ä‡ Å¼Ä…daÅ„ byÅ‚a kolejkowana. Przy kolejnych fazach widaÄ‡, Å¼e tendencja siÄ™ jeszcze zaostrzaÅ‚a i przy 50 uÅ¼ytkownikach czas oczekiwania na aplikacjÄ™ byÅ‚ tak dÅ‚ugi, Å¼e â€œleciaÅ‚yâ€ timeouty. Wiemy oczywiÅ›cie z czego to wynika. UÅ¼ycie â€œsleepâ€ z duÅ¼ymi wartoÅ›ciami jest maÅ‚o wydajne. JeÅ›li to usuniemy, otrzymamy duÅ¼o wiÄ™ksze wartoÅ›ci.</p>

<p><img src="/assets/img/posts/2017-08-01-gatling/2.png" alt="Wyniki testÃ³w" /></p>

<p>Czy nie jest wspaniaÅ‚e, Å¼e Gatling wygenerowaÅ‚ za nas wyniki i pokazaÅ‚ w graficznej formie? Jak dla mnie super. MoÅ¼emy sprawdziÄ‡ podstawowe dane, takie jak liczbÄ™ aktywnych uÅ¼ytkownikÃ³w, czasy odpowiedzi, liczbÄ™ Å¼Ä…daÅ„ i odpowiedzi w czasie. Dodatkowo, moÅ¼emy wybraÄ‡ jeden krok i przeanalizowaÄ‡ w izolacji w ten sam sposÃ³b. Poza tym, przedstawione mamy statystyki w liczbach, takie jak, minimalny i maksymalny czas, Å›rednia, odchylenie standardowe czy liczba requestÃ³w z podziaÅ‚em na zakoÅ„czone sukcesem i bÅ‚Ä™dem. Gatling przedstawia takÅ¼e czasy poszczegÃ³lnych udziaÅ‚Ã³w procentowych obsÅ‚ugi Å¼Ä…daÅ„. Dostajemy zatem informacje ile trwaÅ‚o 50%, 75%, 95% i 99% wywoÅ‚aÅ„. Ten prosty raport naprawdÄ™ sprawia, Å¼e praca z Gatlingiem i testami wydajnoÅ›ciowymi jest przyjemnoÅ›ciÄ….</p>

<h2 id="testowanie-wydajnoÅ›ci-poprzez-gatling">Testowanie wydajnoÅ›ci poprzez Gatling</h2>
<p>PodsumowujÄ…c moje doÅ›wiadczenia w pracy z Gatlingiem, mogÄ™ stwierdziÄ‡, Å¼e wybÃ³r tego narzÄ™dzia byÅ‚ â€œstrzaÅ‚em w dziesÄ…tkÄ™â€. Jego istotnÄ… zaletÄ… jest to, Å¼e scenariusze testowe sÄ… pisane jako zwykÅ‚y kod. Nie ma problemu, aby scenariusz przygotowywaÅ‚o wiÄ™cej osÃ³b. Problemy z â€œmergowaniemâ€ zazwyczaj sÄ… minimalne. Kod jest czytelny i nie ma potrzeby pisania dodatkowej dokumentacji.</p>

<p>Gatling zawiera ponadto masÄ™ pomocniczych poleceÅ„. Na stronie <a href="http://gatling.io/">http://gatling.io/</a> dostÄ™pna jest uÅ¼yteczna dokumentacja, w ktÃ³rej w przejrzysty sposÃ³b wyjaÅ›niono dostÄ™pne funkcje. MoÅ¼emy korzystaÄ‡ bezpoÅ›rednio z poleceÅ„ JMXâ€™a naszego serwera, czy tworzyÄ‡ komunikaty na kolejkach JMS. Produkt jest rozwijany. PowstajÄ… nowe wersje, a bÅ‚Ä™dy sÄ… rozwiÄ…zywane. W przypadku problemÃ³w, moÅ¼na skorzystaÄ‡ z pomocy spoÅ‚ecznoÅ›ci odpowiedzialnej za rozwÃ³j narzÄ™dzia.</p>

<p>Jak kaÅ¼de narzÄ™dzie, rÃ³wnieÅ¼ Gatling ma ograniczonÄ… liczbÄ™ funkcji. JeÅ›li w dokumentacji nie znajdziemy potrzebnych poleceÅ„, moÅ¼emy sprÃ³bowaÄ‡ zapisaÄ‡ np. dane w sesji i posiÅ‚kowaÄ‡ siÄ™ kodem napisanym przez nas w scali. Daje nam to ogrom moÅ¼liwoÅ›ci. Zapewnia elastycznoÅ›Ä‡ w rozwiÄ…zywaniu specyficznych przypadkÃ³w, ktÃ³re niestety spotykamy praktycznie codziennie.</p>

<p>Kolejnym waÅ¼nym uÅ‚atwieniem wykonywania testÃ³w jest raport koÅ„cowy. Automatycznie generowane wykresy i podstawowe statystyki bardzo przydajÄ… siÄ™ w poczÄ…tkowej i koÅ„cowej fazie testu. JeÅ›li chcemy, szybko przetestowaÄ‡ aplikacjÄ™ z ogromnym ruchem, nie ma problemu -zmieniamy 2-3 linijki i odpalamy. Po kilku chwilach mamy dostÄ™pne wyniki i wiemy, czy aplikacja daje radÄ™, czy juÅ¼ nie. Tej funkcjonalnoÅ›ci mi zawsze brakowaÅ‚o np. w JMeterze, gdzie raportem byÅ‚o trzeba zajÄ…Ä‡ siÄ™ samemu po testach. W przypadku Gatlinga wyniki moÅ¼emy bez problemu doÅ‚Ä…czyÄ‡ do dokumentacji produktu, jako potwierdzenie naszej ciÄ™Å¼kiej i dobrze wykonanej pracy przy pisaniu aplikacji i testach wydajnoÅ›ciowych. Polecam kaÅ¼demu wyprÃ³bowanie Gatlinga do testÃ³w wydajnoÅ›ciowych. Mi narzÄ™dzie to bardzo mocno przypadÅ‚o do gustu.</p>
:ET